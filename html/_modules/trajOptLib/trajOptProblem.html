

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>trajOptLib.trajOptProblem &mdash; trajoptlib  documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> trajoptlib
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <!-- Local TOC -->
              <div class="local-toc"></div>
            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">trajoptlib</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>trajOptLib.trajOptProblem</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for trajOptLib.trajOptProblem</h1><div class="highlight"><pre>
<span></span><span class="ch">#! /usr/bin/env python</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1"># vim:fenc=utf-8</span>
<span class="c1">#</span>
<span class="c1"># Copyright © 2018 Gao Tang &lt;gt70@duke.edu&gt;</span>
<span class="c1">#</span>
<span class="c1"># Distributed under terms of the MIT license.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">trajOptProblem.py</span>

<span class="sd">Class for describing the trajectory optimization problems.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">.trajOptBase</span> <span class="k">import</span> <span class="n">linearObj</span><span class="p">,</span> <span class="n">linearPointObj</span>
<span class="kn">from</span> <span class="nn">.trajOptBase</span> <span class="k">import</span> <span class="n">linearPointConstr</span><span class="p">,</span> <span class="n">linearConstr</span>
<span class="kn">from</span> <span class="nn">.trajOptBase</span> <span class="k">import</span> <span class="n">nonLinearPointObj</span><span class="p">,</span> <span class="n">nonLinearObj</span>
<span class="kn">from</span> <span class="nn">.trajOptBase</span> <span class="k">import</span> <span class="n">nonLinearPointConstr</span><span class="p">,</span> <span class="n">nonLinearConstr</span>
<span class="kn">from</span> <span class="nn">.trajOptBase</span> <span class="k">import</span> <span class="n">system</span><span class="p">,</span> <span class="n">addX</span>
<span class="kn">from</span> <span class="nn">.trajOptBase</span> <span class="k">import</span> <span class="n">lqrObj</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">SnoptConfig</span> <span class="k">as</span> <span class="n">snoptConfig</span><span class="p">,</span> <span class="n">probFun</span><span class="p">,</span> <span class="n">solver</span>
<span class="kn">from</span> <span class="nn">.utility</span> <span class="k">import</span> <span class="n">parseX</span><span class="p">,</span> <span class="n">randomGenInBound</span><span class="p">,</span> <span class="n">checkInBounds</span><span class="p">,</span> <span class="n">interp</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">sparse</span>
<span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="k">import</span> <span class="n">spmatrix</span><span class="p">,</span> <span class="n">coo_matrix</span>


<div class="viewcode-block" id="trajOptProblem"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptProblem.trajOptProblem">[docs]</a><span class="k">class</span> <span class="nc">trajOptProblem</span><span class="p">(</span><span class="n">probFun</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A class for definition of trajectory optimization problem.</span>

<span class="sd">    A general framework for using this class is to:</span>

<span class="sd">    1. Define a class inherited from system and write dyn/Jdyn method.</span>
<span class="sd">    2. Optionally, write desired cost function by inheriting/creating from the list of available cost functions.</span>
<span class="sd">    3. Optionally, write desired constraint functions by inheriting from available constraints.</span>
<span class="sd">    4. Create this class with selected system, discretization, t0, tf range, gradient option</span>
<span class="sd">    5. Set bounds for state, control, parameters, x0 and xf</span>
<span class="sd">    6. Add objective functions and constraints to this class</span>
<span class="sd">    7. Call preProcess method explicitly</span>
<span class="sd">    8. Create snoptConfig instance and choose desired options</span>
<span class="sd">    9. Construct the solver</span>
<span class="sd">    10. Use the solver to solve with either automatic guess or user provided guess</span>

<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="trajOptProblem.__init__"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptProblem.trajOptProblem.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sys</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">tf</span><span class="p">,</span> <span class="n">gradmode</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">addx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize problem by system, discretization grid size, and allowable time</span>

<span class="sd">        :param sys: system, describe system dynamics</span>
<span class="sd">        :param N: int, discretization grid size, a uniform grid</span>
<span class="sd">        :param t0: float/array like, allowable t0</span>
<span class="sd">        :param tf: float/array like, allowable tf</span>
<span class="sd">        :param gradmode: bool, sets if we use gradient mode.</span>
<span class="sd">        :param addX: list of addX / one addX / None, additional optimization variables.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sys</span><span class="p">,</span> <span class="n">system</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sys</span> <span class="o">=</span> <span class="n">sys</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="n">N</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tf</span> <span class="o">=</span> <span class="n">tf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t0</span> <span class="o">=</span> <span class="n">t0</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">tf</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fixtf</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fixtf</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">assert</span> <span class="n">tf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">tf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">t0</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fixt0</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fixt0</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">assert</span> <span class="n">t0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">t0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gradmode</span> <span class="o">=</span> <span class="n">gradmode</span>  <span class="c1"># this controls if __callg__ will be called</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">nx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimu</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">nu</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimp</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">np</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimpoint</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">nx</span> <span class="o">+</span> <span class="n">sys</span><span class="o">.</span><span class="n">nu</span> <span class="o">+</span> <span class="n">sys</span><span class="o">.</span><span class="n">np</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ubd</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xbd</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pbd</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x0bd</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xfbd</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="c1"># lqr cost function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lqrObj</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Linear cost function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linearObj</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># stores general linear cost</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linPointObj</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># stores linear cost imposed at a point</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linPathObj</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># stores Lagrange integral cost</span>
        <span class="c1"># nonlinear cost function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonLinObj</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># stores general nonlinear cost</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonPointObj</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># stores nonlinear cost imposed at a point</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonPathObj</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># stores Lagrange integral cost. Includes LQR cost</span>
        <span class="c1"># nonlinear constraints. Linear constraints are treated as nonlinear</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pointConstr</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># general constraint imposed at a certain point, such as initial and final point</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pathConstr</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># general constraint imposed everywhere such as collision avoidance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonLinConstr</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># stores general nonlinear constraint</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linPointConstr</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linPathConstr</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linearConstr</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># calculate number of variables to be optimized, time are always the last</span>
        <span class="n">numX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span>
        <span class="n">numU</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimu</span>
        <span class="n">numP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimp</span>
        <span class="k">if</span> <span class="n">addx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lenAddX</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">addx</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">addx</span> <span class="o">=</span> <span class="p">[</span><span class="n">addx</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">tmp</span> <span class="ow">in</span> <span class="n">addx</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">addX</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addX</span> <span class="o">=</span> <span class="n">addx</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lenAddX</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">tmp</span><span class="o">.</span><span class="n">n</span> <span class="k">for</span> <span class="n">tmp</span> <span class="ow">in</span> <span class="n">addx</span><span class="p">])</span>
        <span class="n">numT</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixt0</span><span class="p">:</span>
            <span class="n">numT</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixtf</span><span class="p">:</span>
            <span class="n">numT</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">numSol</span> <span class="o">=</span> <span class="n">numX</span> <span class="o">+</span> <span class="n">numU</span> <span class="o">+</span> <span class="n">numP</span> <span class="o">+</span> <span class="n">numT</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numX</span> <span class="o">=</span> <span class="n">numX</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numU</span> <span class="o">=</span> <span class="n">numU</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numP</span> <span class="o">=</span> <span class="n">numP</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numT</span> <span class="o">=</span> <span class="n">numT</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numTraj</span> <span class="o">=</span> <span class="n">numSol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numSol</span> <span class="o">=</span> <span class="n">numSol</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">lenAddX</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t0ind</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tfind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__getTimeIndices</span><span class="p">()</span></div>

<div class="viewcode-block" id="trajOptProblem.pre_process"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptProblem.trajOptProblem.pre_process">[docs]</a>    <span class="k">def</span> <span class="nf">pre_process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the instances of probFun now we are ready.</span>

<span class="sd">        Call this function after the objectives and constraints have been set appropriately.</span>
<span class="sd">        It calculate the space required for SNOPT and allocates sparsity structure if necessary.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">numDyn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># constraints from system dynamics</span>
        <span class="n">numC</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">constr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointConstr</span><span class="p">:</span>
            <span class="n">numC</span> <span class="o">+=</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span>
        <span class="k">for</span> <span class="n">constr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pathConstr</span><span class="p">:</span>
            <span class="n">numC</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">*</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span>
        <span class="k">for</span> <span class="n">constr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonLinConstr</span><span class="p">:</span>
            <span class="n">numC</span> <span class="o">+=</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span>
        <span class="n">nnonlincon</span> <span class="o">=</span> <span class="n">numC</span>
        <span class="k">for</span> <span class="n">constr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">linPointConstr</span><span class="p">:</span>
            <span class="n">numC</span> <span class="o">+=</span> <span class="n">constr</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">constr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">linPathConstr</span><span class="p">:</span>
            <span class="n">numC</span> <span class="o">+=</span> <span class="n">constr</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span>  <span class="c1"># this remains being argued</span>
        <span class="k">for</span> <span class="n">constr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">linearConstr</span><span class="p">:</span>
            <span class="n">numC</span> <span class="o">+=</span> <span class="n">constr</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numF</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">numDyn</span> <span class="o">+</span> <span class="n">numC</span>
        <span class="c1"># time to analyze all objective functions in order to detect pattern for A, and additional variables for other nonlinear objective function</span>
        <span class="n">spA</span><span class="p">,</span> <span class="n">addn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__analyzeObj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numSol</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numF</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">objaddn</span> <span class="o">=</span> <span class="n">addn</span>  <span class="c1"># this is important for multiple objective function support</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numSol</span> <span class="o">+=</span> <span class="n">addn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numF</span> <span class="o">+=</span> <span class="n">addn</span>
        <span class="n">probFun</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numSol</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numF</span><span class="p">)</span>  <span class="c1"># currently we do not know G yet</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__setAPattern</span><span class="p">(</span><span class="n">numDyn</span><span class="p">,</span> <span class="n">nnonlincon</span><span class="p">,</span> <span class="n">spA</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__setXbound</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__setFbound</span><span class="p">()</span>
        <span class="c1"># detect gradient information</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gradmode</span><span class="p">:</span>  <span class="c1"># in this case, we randomly generate a guess and use it to initialize everything</span>
            <span class="n">randX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">randomGenX</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__turnOnGrad</span><span class="p">(</span><span class="n">randX</span><span class="p">)</span></div>

<div class="viewcode-block" id="trajOptProblem.genGuessFromTraj"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptProblem.trajOptProblem.genGuessFromTraj">[docs]</a>    <span class="k">def</span> <span class="nf">genGuessFromTraj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">U</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">P</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">t0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">addx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tstamp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">obj</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">interp_kind</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate an initial guess for the problem with user specified information.</span>

<span class="sd">        An amazing feature is the user does not have to give a solution of exactly the same time-stamped trajectory used internally.</span>
<span class="sd">        Interpolation approaches are used in such scenarios.</span>
<span class="sd">        The user is not required to provide them all, although we suggest they do so.</span>

<span class="sd">        :param X: ndarray, (x, x) each row corresponds to a state snapshot (if tstamp is None, assume equidistant grid). Column size can be dimx or dimx/sys.order</span>
<span class="sd">        :param U: ndarray, (x, dimu) each row corresponds to a control snapshot. Similar to X but with column size equals dimu</span>
<span class="sd">        :param P: ndarray, (x, dimp) each row corresponds to a parameter snapshot. Similar to X but with column size equals dimp</span>
<span class="sd">        :param t0/tf: float/array-like, initial/final time. If None, we randomly generate one</span>
<span class="sd">        :param addx: list of ndarray, guess of addx, if applicable</span>
<span class="sd">        :param tstamp: ndarray, (x,), None if the X/U/P are provided using equidistant grid.</span>
<span class="sd">        :param obj: ndarray, (x,) the objective part</span>
<span class="sd">        :param interp_kind: str, interpolation type for scipy.interpolate.interp1d, can be (‘linear’, ‘nearest’, ‘zero’, ‘slinear’, ‘quadratic’, ‘cubic’)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">randX</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numSol</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">Xtarget</span><span class="p">,</span> <span class="n">Utarget</span><span class="p">,</span> <span class="n">Ptarget</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parseX__</span><span class="p">(</span><span class="n">randX</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">obj_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parseObj__</span><span class="p">(</span><span class="n">randX</span><span class="p">)</span>
            <span class="n">obj_</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">obj</span>
        <span class="c1"># generate t0 and tf, if applicable</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0ind</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">t0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">randX</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">t0ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">randomGenInBound</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">randX</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">t0ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">randomGenInBound</span><span class="p">(</span><span class="n">t0</span><span class="p">)</span>
            <span class="n">uset0</span> <span class="o">=</span> <span class="n">randX</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">t0ind</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">uset0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tfind</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">randX</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tfind</span><span class="p">]</span> <span class="o">=</span> <span class="n">randomGenInBound</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tf</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">randX</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tfind</span><span class="p">]</span> <span class="o">=</span> <span class="n">randomGenInBound</span><span class="p">(</span><span class="n">tf</span><span class="p">)</span>
            <span class="n">usetf</span> <span class="o">=</span> <span class="n">randX</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tfind</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">usetf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tf</span>
        <span class="n">teval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">uset0</span><span class="p">,</span> <span class="n">usetf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>

        <span class="c1"># interpolation for state variables</span>
        <span class="n">nPoint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span>
        <span class="n">dimx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span>
        <span class="k">if</span> <span class="n">X</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Xcol</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">Xcol</span> <span class="o">==</span> <span class="n">dimx</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The column of X is not </span><span class="si">%d</span><span class="s1"> or </span><span class="si">%d</span><span class="s1">, not use it&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dimx</span><span class="p">))</span>
                <span class="n">X</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># use interpolation to do it</span>
                <span class="n">interp</span><span class="p">(</span><span class="n">tstamp</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">teval</span><span class="p">,</span> <span class="n">Xtarget</span><span class="p">,</span> <span class="n">interp_kind</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">X</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># straight path go there</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nPoint</span><span class="p">):</span>
                <span class="n">Xtarget</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">randomGenInBound</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xbd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span><span class="p">)</span>
            <span class="c1"># randomly generate x0 and xf</span>
            <span class="n">Xtarget</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:</span><span class="n">dimx</span><span class="p">]</span> <span class="o">=</span> <span class="n">randomGenInBound</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x0bd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span><span class="p">)</span>
            <span class="n">Xtarget</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="n">dimx</span><span class="p">]</span> <span class="o">=</span> <span class="n">randomGenInBound</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xfbd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span><span class="p">)</span>

        <span class="c1"># interpolation for control variable</span>
        <span class="k">if</span> <span class="n">U</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">interp</span><span class="p">(</span><span class="n">tstamp</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">teval</span><span class="p">,</span> <span class="n">Utarget</span><span class="p">,</span> <span class="n">interp_kind</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nPoint</span><span class="p">):</span>
                <span class="n">Utarget</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">randomGenInBound</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ubd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimu</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">numP</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">P</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">interp</span><span class="p">(</span><span class="n">tstamp</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">teval</span><span class="p">,</span> <span class="n">Ptarget</span><span class="p">,</span> <span class="n">interp_kind</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nPoint</span><span class="p">):</span>
                    <span class="n">Ptarget</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">randomGenInBound</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pbd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimp</span><span class="p">)</span>
        <span class="c1"># generate for</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lenAddX</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">addx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="n">addx_</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__parseAddX__</span><span class="p">(</span><span class="n">randX</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">addX</span><span class="p">):</span>
                    <span class="n">field</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">randomGenInBound</span><span class="p">([</span><span class="n">addx_</span><span class="o">.</span><span class="n">lb</span><span class="p">,</span> <span class="n">addx_</span><span class="o">.</span><span class="n">ub</span><span class="p">],</span> <span class="n">addx_</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">guess</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">addx_</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">addx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parseAddX__</span><span class="p">(</span><span class="n">randX</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">addX</span><span class="p">):</span>
                    <span class="n">field</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">randomGenInBound</span><span class="p">(</span><span class="n">guess</span><span class="p">,</span> <span class="n">addx_</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
        <span class="c1"># I do not have to worry about objaddn since they are linear</span>
        <span class="k">return</span> <span class="n">randX</span></div>

<div class="viewcode-block" id="trajOptProblem.preProcess"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptProblem.trajOptProblem.preProcess">[docs]</a>    <span class="k">def</span> <span class="nf">preProcess</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Alias for pre_process&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pre_process</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__analyzeObj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">numSol</span><span class="p">,</span> <span class="n">numF</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Analyze the objective function.</span>

<span class="sd">        :param numSol: current estimation of free variables</span>
<span class="sd">        :param numF: current estimation of rows of constraints</span>
<span class="sd">        :return spA: coo sparse matrix, records first row of A, and last rows of A</span>
<span class="sd">        :return addn: int, additional nonlinear constraint. As long as nonlinear obj exists, this is non-zero</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># detect how many nonlinear objective functions we have</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lqrObj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nnlin</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nnlin</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">nnlin</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonLinObj</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonPathObj</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonPointObj</span><span class="p">)</span>
        <span class="n">addn</span> <span class="o">=</span> <span class="n">nnlin</span>
        <span class="c1"># analyze the linear objective functions in a good way</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">numSol</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">linearObj</span><span class="p">:</span>
            <span class="n">A</span><span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">col</span><span class="p">]</span> <span class="o">+=</span> <span class="n">obj</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">data</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">linPointObj</span><span class="p">:</span>
            <span class="n">A</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">__patchCol__</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">col</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">obj</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">data</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">linPathObj</span><span class="p">:</span>  <span class="c1"># this is not particularly useful, I have to say</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numPoint</span><span class="p">):</span>
                <span class="n">A</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">__patchCol__</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">col</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">obj</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">data</span>
        <span class="c1"># get sparse representation of A</span>
        <span class="n">nnzind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">A</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">A_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">addn</span><span class="p">)</span>
        <span class="n">row_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">addn</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">col_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">addn</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="c1"># for the addn</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">addn</span><span class="p">):</span>
            <span class="n">A_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">A_</span><span class="p">[</span><span class="n">addn</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">col_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">numSol</span> <span class="o">+</span> <span class="n">i</span>
            <span class="n">col_</span><span class="p">[</span><span class="n">addn</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">numSol</span> <span class="o">+</span> <span class="n">i</span>
            <span class="n">row_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">row_</span><span class="p">[</span><span class="n">addn</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">numF</span> <span class="o">+</span> <span class="n">i</span>
        <span class="c1"># concat them</span>
        <span class="n">catA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">A</span><span class="p">[</span><span class="n">nnzind</span><span class="p">],</span> <span class="n">A_</span><span class="p">))</span>
        <span class="n">catArow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nnzind</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> <span class="n">row_</span><span class="p">))</span>
        <span class="n">catAcol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">nnzind</span><span class="p">,</span> <span class="n">col_</span><span class="p">))</span>
        <span class="n">spA</span> <span class="o">=</span> <span class="n">coo_matrix</span><span class="p">((</span><span class="n">catA</span><span class="p">,</span> <span class="p">(</span><span class="n">catArow</span><span class="p">,</span> <span class="n">catAcol</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">spA</span><span class="p">,</span> <span class="n">addn</span>

    <span class="k">def</span> <span class="nf">__setAPattern</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ndyncon</span><span class="p">,</span> <span class="n">nnonlincon</span><span class="p">,</span> <span class="n">spA</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set sparsity pattern for A. curRow is current row.</span>

<span class="sd">        It finds sparsity pattern from defect constraints.</span>
<span class="sd">        It also finds sparsity pattern from those linear constraints.</span>

<span class="sd">        :param ndyncon: int, describes how many dynamics constraints we have</span>
<span class="sd">        :param nnonlincon: int, describes how many nonlinear constraints we have</span>
<span class="sd">        :param spA: sparse matrix, how the objective function is described linearly.</span>
<span class="sd">        :return curRow: current row number after setting linear constraint</span>
<span class="sd">        :return curNA: current length of A</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dimx</span><span class="p">,</span> <span class="n">dimu</span><span class="p">,</span> <span class="n">dimp</span><span class="p">,</span> <span class="n">dimpoint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimpoint</span>
        <span class="c1"># find those linear constraints</span>
        <span class="n">curRow</span> <span class="o">=</span> <span class="n">ndyncon</span> <span class="o">+</span> <span class="n">nnonlincon</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># since first row is objective</span>
        <span class="n">lstCA</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">lstCArow</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">lstCAcol</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">constr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">linPointConstr</span><span class="p">:</span>
            <span class="n">lstCA</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">constr</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="n">lstCArow</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">constr</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">row</span> <span class="o">+</span> <span class="n">curRow</span><span class="p">)</span>
            <span class="n">lstCAcol</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__patchCol__</span><span class="p">(</span><span class="n">constr</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">constr</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">col</span><span class="p">))</span>  <span class="c1"># take care on here</span>
            <span class="n">curRow</span> <span class="o">+=</span> <span class="n">constr</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">constr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">linPathConstr</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
                <span class="n">lstCA</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">constr</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
                <span class="n">lstCArow</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">constr</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">row</span> <span class="o">+</span> <span class="n">curRow</span><span class="p">)</span>
                <span class="n">lstCAcol</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__patchCol__</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">constr</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">col</span><span class="p">))</span>
                <span class="n">curRow</span> <span class="o">+=</span> <span class="n">constr</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">constr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">linearConstr</span><span class="p">:</span>
            <span class="n">lstCA</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">constr</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="n">lstCArow</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">constr</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">row</span> <span class="o">+</span> <span class="n">curRow</span><span class="p">)</span>
            <span class="n">lstCAcol</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">constr</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">col</span><span class="p">)</span>
            <span class="n">curRow</span> <span class="o">+=</span> <span class="n">constr</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># for python3 compaticity, I extend the list</span>
        <span class="n">lstCA</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spA</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="n">lstCArow</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spA</span><span class="o">.</span><span class="n">row</span><span class="p">)</span>
        <span class="n">lstCAcol</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spA</span><span class="o">.</span><span class="n">col</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Aval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">lstCA</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Arow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">lstCArow</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Acol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">lstCAcol</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_a_by_triplet</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Aval</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Arow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Acol</span><span class="p">)</span>
        <span class="n">curNA</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Aval</span><span class="p">)</span>  <span class="c1"># this is just for bookkeeping</span>
        <span class="k">return</span> <span class="n">curRow</span><span class="p">,</span> <span class="n">curNA</span>

<div class="viewcode-block" id="trajOptProblem.randomGenX"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptProblem.trajOptProblem.randomGenX">[docs]</a>    <span class="k">def</span> <span class="nf">randomGenX</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A more reansonable approach to generate random guess for the problem.</span>

<span class="sd">        It considers bounds on initial and final states so this is satisfied.</span>
<span class="sd">        Then it linearly interpolate between states.</span>
<span class="sd">        Controls are randomly generated within control bound, if it presents. Otherwise [-1, 1]</span>

<span class="sd">        :return x: ndarray, (numSol, ) an initial guess of the solution</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">randX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numSol</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">randX</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">numX</span><span class="p">],</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span><span class="p">))</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">randX</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">numX</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">numX</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">numU</span><span class="p">],</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimu</span><span class="p">))</span>
        <span class="c1"># randomly generate x0 and xf</span>
        <span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">randomGenInBound</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x0bd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span><span class="p">)</span>
        <span class="n">X</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">randomGenInBound</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xfbd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span><span class="p">)</span>
        <span class="c1"># straight path go there</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimx</span><span class="p">):</span>
            <span class="n">X</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
            <span class="n">U</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">randomGenInBound</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ubd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimu</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">numP</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">randX</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">numX</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">numU</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">numX</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">numU</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">numP</span><span class="p">],</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimp</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
                <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">randomGenInBound</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pbd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimp</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0ind</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">randX</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">t0ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">randomGenInBound</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t0</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tfind</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">randX</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tfind</span><span class="p">]</span> <span class="o">=</span> <span class="n">randomGenInBound</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tf</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lenAddX</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="n">addx</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__parseAddX__</span><span class="p">(</span><span class="n">randX</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">addX</span><span class="p">):</span>
                <span class="n">field</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">randomGenInBound</span><span class="p">([</span><span class="n">addx</span><span class="o">.</span><span class="n">lb</span><span class="p">,</span> <span class="n">addx</span><span class="o">.</span><span class="n">ub</span><span class="p">],</span> <span class="n">addx</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
        <span class="c1"># I do not have to worry about objaddn since they are linear</span>
        <span class="k">return</span> <span class="n">randX</span></div>

    <span class="k">def</span> <span class="nf">__turnOnGrad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Turn on gradient, this is called after an initial x0 has been generated&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grad</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__getSparsity</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getSparsity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Detect sparsity of the problem with an initial guess.&quot;&quot;&quot;</span>
        <span class="n">numObjG</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__getObjSparsity</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numObjG</span> <span class="o">=</span> <span class="n">numObjG</span>
        <span class="c1"># summarize number of pure linear constraints</span>
        <span class="n">numDynG</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__getDynSparsity</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
        <span class="n">numCG</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># G from C</span>
        <span class="c1"># I only care about those in numC</span>
        <span class="k">for</span> <span class="n">constr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointConstr</span><span class="p">:</span>
            <span class="n">numCG</span> <span class="o">+=</span> <span class="n">constr</span><span class="o">.</span><span class="n">nG</span>
        <span class="k">for</span> <span class="n">constr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pathConstr</span><span class="p">:</span>
            <span class="n">numCG</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">*</span> <span class="n">constr</span><span class="o">.</span><span class="n">nG</span>
        <span class="k">for</span> <span class="n">constr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonLinConstr</span><span class="p">:</span>
            <span class="n">numCG</span> <span class="o">+=</span> <span class="n">constr</span><span class="o">.</span><span class="n">nG</span>
        <span class="n">numG</span> <span class="o">=</span> <span class="n">numObjG</span> <span class="o">+</span> <span class="n">numDynG</span> <span class="o">+</span> <span class="n">numCG</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numG</span> <span class="o">=</span> <span class="n">numG</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nG</span> <span class="o">=</span> <span class="n">numG</span>

    <span class="k">def</span> <span class="nf">__getDynSparsity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set sparsity of the problem caused by system dynamics and other nonlinear constraints.</span>

<span class="sd">        :param x: ndarray, the guess/sol</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: now sparsity is supported for Euler/ BackEuler/ Dis, RK4 needs to be done</span>
        <span class="n">h</span><span class="p">,</span> <span class="n">useT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__getTimeGrid</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">useX</span><span class="p">,</span> <span class="n">useU</span><span class="p">,</span> <span class="n">useP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parseX__</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="c1"># use one time/state/ctrl/para/h set to detect the sparsity pattern</span>
        <span class="n">ydot</span><span class="p">,</span> <span class="n">Jac</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sys</span><span class="o">.</span><span class="n">Jdyn</span><span class="p">(</span><span class="n">useT</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">useX</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">useU</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">useP</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">nrow</span><span class="p">,</span> <span class="n">ncol</span> <span class="o">=</span> <span class="n">Jac</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">Jac</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">nnz</span> <span class="o">=</span> <span class="n">nrow</span> <span class="o">*</span> <span class="n">ncol</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dynSparse</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">Jac</span><span class="p">,</span> <span class="n">spmatrix</span><span class="p">):</span>
            <span class="n">nnz</span> <span class="o">=</span> <span class="n">Jac</span><span class="o">.</span><span class="n">nnz</span>  <span class="c1"># TODO: this is dangerous since nnz might be misleading</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dynSparse</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynSparse</span><span class="p">:</span>
            <span class="n">dynG</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimpoint</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">numT</span><span class="p">)</span>  <span class="c1"># G from dyn</span>
            <span class="k">return</span> <span class="n">dynG</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># if sparse, then treat dis and Euler separately</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sys</span><span class="o">.</span><span class="n">ode</span> <span class="o">==</span> <span class="s1">&#39;Dis&#39;</span><span class="p">:</span>
                <span class="n">timennz</span> <span class="o">=</span> <span class="n">Jac</span><span class="o">.</span><span class="n">getcol</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">nnz</span> <span class="o">+</span> <span class="n">Jac</span><span class="o">.</span><span class="n">getcol</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">nnz</span>
                <span class="n">dynnnz</span> <span class="o">=</span> <span class="n">nnz</span> <span class="o">-</span> <span class="n">timennz</span>
                <span class="n">dynG</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">dynnnz</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">numT</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">timennz</span> <span class="o">=</span> <span class="n">Jac</span><span class="o">.</span><span class="n">getcol</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">nnz</span>  <span class="c1"># TODO: this is in fact wrong</span>
                <span class="n">eyemat</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimx</span><span class="p">),</span> <span class="n">offsets</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">Jac</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="n">Jac</span> <span class="o">=</span> <span class="n">Jac</span><span class="o">.</span><span class="n">tocoo</span><span class="p">()</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sys</span><span class="o">.</span><span class="n">ode</span> <span class="o">==</span> <span class="s1">&#39;Euler&#39;</span><span class="p">:</span>
                    <span class="n">Jac</span><span class="o">.</span><span class="n">data</span> <span class="o">*=</span> <span class="n">h</span>
                    <span class="c1"># add a block by identity</span>
                    <span class="n">Jac</span> <span class="o">=</span> <span class="n">Jac</span> <span class="o">+</span> <span class="n">eyemat</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">sys</span><span class="o">.</span><span class="n">ode</span> <span class="o">==</span> <span class="s1">&#39;BackEuler&#39;</span><span class="p">:</span>
                    <span class="n">Jac</span><span class="o">.</span><span class="n">data</span> <span class="o">*=</span> <span class="p">(</span><span class="o">-</span><span class="n">h</span><span class="p">)</span>
                    <span class="n">Jac</span> <span class="o">=</span> <span class="n">Jac</span> <span class="o">+</span> <span class="n">eyemat</span>
                <span class="n">dynnnz</span> <span class="o">=</span> <span class="n">Jac</span><span class="o">.</span><span class="n">nnz</span> <span class="o">-</span> <span class="n">timennz</span>
                <span class="n">dynG</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">dynnnz</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">numT</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">dynG</span>

    <span class="k">def</span> <span class="nf">__getObjSparsity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set sparsity structure of the problem from objective function.</span>

<span class="sd">        The objective function pattern is composed of two parts:</span>
<span class="sd">        - linear parts. We sum all the coefficients and find sparsity pattern out of it</span>
<span class="sd">        - nonlinear parts. Each nonlinear objective is augmented with another row in jacobian</span>
<span class="sd">        and a another auxiliary optimization variable s.t. c(x) = y and J += y</span>

<span class="sd">        :param x: ndarray, the guess/sol</span>
<span class="sd">        :returns: nG: int, # Jacobian from nonlinear objective function</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">h</span><span class="p">,</span> <span class="n">useT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__getTimeGrid</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">useX</span><span class="p">,</span> <span class="n">useU</span><span class="p">,</span> <span class="n">useP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parseX__</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">nG</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># check sparseObj mode</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lqrObj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nG</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LQRnG</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonLinObj</span><span class="p">:</span>
            <span class="n">nG</span> <span class="o">+=</span> <span class="n">obj</span><span class="o">.</span><span class="n">nG</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonPointObj</span><span class="p">:</span>
            <span class="n">nG</span> <span class="o">+=</span> <span class="n">obj</span><span class="o">.</span><span class="n">nG</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonPathObj</span><span class="p">:</span>
            <span class="n">nG</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">obj</span><span class="o">.</span><span class="n">nG</span>
        <span class="k">return</span> <span class="n">nG</span>

    <span class="k">def</span> <span class="nf">__getTimeIndices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Utility function for assigning sparsity structure.&quot;&quot;&quot;</span>
        <span class="n">t0ind</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">tfind</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">lenX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimpoint</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixt0</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixtf</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tfind</span> <span class="o">=</span> <span class="n">lenX</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixtf</span><span class="p">:</span>
                <span class="n">t0ind</span> <span class="o">=</span> <span class="n">lenX</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">t0ind</span> <span class="o">=</span> <span class="n">lenX</span>
                <span class="n">tfind</span> <span class="o">=</span> <span class="n">lenX</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">t0ind</span><span class="p">,</span> <span class="n">tfind</span>

    <span class="k">def</span> <span class="nf">__setXbound</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set bounds on decision variables.&quot;&quot;&quot;</span>
        <span class="c1"># create bound on x</span>
        <span class="n">dimpnt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimpoint</span>
        <span class="n">dimx</span><span class="p">,</span> <span class="n">dimu</span><span class="p">,</span> <span class="n">dimp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimp</span>
        <span class="n">xlb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numSol</span><span class="p">)</span>
        <span class="n">xub</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numSol</span><span class="p">)</span>
        <span class="n">numDynVar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">*</span> <span class="n">dimpnt</span>
        <span class="n">Mxlb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">xlb</span><span class="p">[:</span><span class="n">numDynVar</span><span class="p">],</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">dimpnt</span><span class="p">))</span>
        <span class="n">Mxub</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">xub</span><span class="p">[:</span><span class="n">numDynVar</span><span class="p">],</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">dimpnt</span><span class="p">))</span>
        <span class="n">Mulb</span> <span class="o">=</span> <span class="n">Mxlb</span><span class="p">[:,</span> <span class="n">dimx</span><span class="p">:</span><span class="n">dimx</span><span class="o">+</span><span class="n">dimu</span><span class="p">]</span>
        <span class="n">Muub</span> <span class="o">=</span> <span class="n">Mxub</span><span class="p">[:,</span> <span class="n">dimx</span><span class="p">:</span><span class="n">dimx</span><span class="o">+</span><span class="n">dimu</span><span class="p">]</span>
        <span class="n">Mplb</span> <span class="o">=</span> <span class="n">Mxlb</span><span class="p">[:,</span> <span class="n">dimpnt</span><span class="o">-</span><span class="n">dimp</span><span class="p">:</span><span class="n">dimpnt</span><span class="p">]</span>
        <span class="n">Mpub</span> <span class="o">=</span> <span class="n">Mxub</span><span class="p">[:,</span> <span class="n">dimpnt</span><span class="o">-</span><span class="n">dimp</span><span class="p">:</span><span class="n">dimpnt</span><span class="p">]</span>
        <span class="c1"># set bounds for q and dq, agree with previous convention</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">xbd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Mxlb</span><span class="p">[:,</span> <span class="p">:</span><span class="n">dimx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xbd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Mxlb</span><span class="p">[:,</span> <span class="p">:</span><span class="n">dimx</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1e20</span>
        <span class="c1"># set lb for x0 and xf</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0bd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Mxlb</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:</span><span class="n">dimx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0bd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">xfbd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Mxlb</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="n">dimx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xfbd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">xbd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Mxub</span><span class="p">[:,</span> <span class="p">:</span><span class="n">dimx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xbd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Mxub</span><span class="p">[:,</span> <span class="p">:</span><span class="n">dimx</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e20</span>
        <span class="c1"># set ub for x0 and xf</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0bd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Mxub</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:</span><span class="n">dimx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0bd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">xfbd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Mxub</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="n">dimx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xfbd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># set bounds for control variable</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ubd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Mulb</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ubd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Mulb</span><span class="p">[:]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1e20</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ubd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Muub</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ubd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Muub</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">1e20</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">Mplb</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Mplb</span><span class="p">[:]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1e20</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">Mpub</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Mpub</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">1e20</span>

        <span class="c1"># set bound on time</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixt0</span><span class="p">:</span>
            <span class="n">xlb</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">t0ind</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">xub</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">t0ind</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixtf</span><span class="p">:</span>
            <span class="n">xlb</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tfind</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">xub</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tfind</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># set bound on addX</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lenAddX</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">curN</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numTraj</span>
            <span class="k">for</span> <span class="n">addx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">addX</span><span class="p">:</span>
                <span class="n">xlb</span><span class="p">[</span><span class="n">curN</span><span class="p">:</span> <span class="n">curN</span> <span class="o">+</span> <span class="n">addx</span><span class="o">.</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">addx</span><span class="o">.</span><span class="n">lb</span>
                <span class="n">xub</span><span class="p">[</span><span class="n">curN</span><span class="p">:</span> <span class="n">curN</span> <span class="o">+</span> <span class="n">addx</span><span class="o">.</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">addx</span><span class="o">.</span><span class="n">ub</span>

        <span class="c1"># set bound on objaddn, this is obvious</span>
        <span class="n">xlb</span><span class="p">[</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">objaddn</span><span class="p">:]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1e20</span>
        <span class="n">xub</span><span class="p">[</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">objaddn</span><span class="p">:]</span> <span class="o">=</span> <span class="mf">1e20</span>

        <span class="c1"># assign to where it should belong to</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_xlb</span><span class="p">(</span><span class="n">xlb</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_xub</span><span class="p">(</span><span class="n">xub</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setFbound</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set bound on F&quot;&quot;&quot;</span>
        <span class="c1"># set bound on F</span>
        <span class="n">numF</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numF</span>
        <span class="n">numDyn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># constraints from system dynamics</span>
        <span class="n">clb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">numF</span><span class="p">)</span>
        <span class="n">cub</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">numF</span><span class="p">)</span>
        <span class="n">clb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1e20</span>
        <span class="n">cub</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e20</span>
        <span class="n">cind0</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">numDyn</span>
        <span class="k">for</span> <span class="n">constr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointConstr</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">constr</span><span class="o">.</span><span class="n">lb</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">clb</span><span class="p">[</span><span class="n">cind0</span><span class="p">:</span> <span class="n">cind0</span> <span class="o">+</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span><span class="p">]</span> <span class="o">=</span> <span class="n">constr</span><span class="o">.</span><span class="n">lb</span>
            <span class="k">if</span> <span class="n">constr</span><span class="o">.</span><span class="n">ub</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">cub</span><span class="p">[</span><span class="n">cind0</span><span class="p">:</span> <span class="n">cind0</span> <span class="o">+</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span><span class="p">]</span> <span class="o">=</span> <span class="n">constr</span><span class="o">.</span><span class="n">ub</span>
            <span class="n">cind0</span> <span class="o">+=</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span>
        <span class="k">for</span> <span class="n">constr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pathConstr</span><span class="p">:</span>
            <span class="n">tmplb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">clb</span><span class="p">[</span><span class="n">cind0</span><span class="p">:</span> <span class="n">cind0</span> <span class="o">+</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">],</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span><span class="p">))</span>
            <span class="n">tmpub</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">cub</span><span class="p">[</span><span class="n">cind0</span><span class="p">:</span> <span class="n">cind0</span> <span class="o">+</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">],</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span><span class="p">))</span>
            <span class="n">cind0</span> <span class="o">+=</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span>
            <span class="k">if</span> <span class="n">constr</span><span class="o">.</span><span class="n">lb</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">tmplb</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">constr</span><span class="o">.</span><span class="n">lb</span>
            <span class="k">if</span> <span class="n">constr</span><span class="o">.</span><span class="n">ub</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">tmpub</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">constr</span><span class="o">.</span><span class="n">ub</span>
        <span class="k">for</span> <span class="n">constr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonLinConstr</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">constr</span><span class="o">.</span><span class="n">lb</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">clb</span><span class="p">[</span><span class="n">cind0</span><span class="p">:</span> <span class="n">cind0</span> <span class="o">+</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span><span class="p">]</span> <span class="o">=</span> <span class="n">constr</span><span class="o">.</span><span class="n">lb</span>
            <span class="k">if</span> <span class="n">constr</span><span class="o">.</span><span class="n">ub</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">cub</span><span class="p">[</span><span class="n">cind0</span><span class="p">:</span> <span class="n">cind0</span> <span class="o">+</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span><span class="p">]</span> <span class="o">=</span> <span class="n">constr</span><span class="o">.</span><span class="n">ub</span>
            <span class="n">cind0</span> <span class="o">+=</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span>
        <span class="c1"># the rest are linear constraints and we should write those bounds, too</span>
        <span class="k">for</span> <span class="n">constr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">linPointConstr</span><span class="p">:</span>
            <span class="n">cindf</span> <span class="o">=</span> <span class="n">cind0</span> <span class="o">+</span> <span class="n">constr</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">clb</span><span class="p">[</span><span class="n">cind0</span><span class="p">:</span> <span class="n">cindf</span><span class="p">]</span> <span class="o">=</span> <span class="n">constr</span><span class="o">.</span><span class="n">lb</span>
            <span class="n">cub</span><span class="p">[</span><span class="n">cind0</span><span class="p">:</span> <span class="n">cindf</span><span class="p">]</span> <span class="o">=</span> <span class="n">constr</span><span class="o">.</span><span class="n">ub</span>
            <span class="n">cind0</span> <span class="o">=</span> <span class="n">cindf</span>
        <span class="k">for</span> <span class="n">constr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">linPathConstr</span><span class="p">:</span>
            <span class="n">cindf</span> <span class="o">=</span> <span class="n">cind0</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">*</span> <span class="n">constr</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">clb</span><span class="p">[</span><span class="n">cind0</span><span class="p">:</span> <span class="n">cindf</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">constr</span><span class="o">.</span><span class="n">lb</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="n">cub</span><span class="p">[</span><span class="n">cind0</span><span class="p">:</span> <span class="n">cindf</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">constr</span><span class="o">.</span><span class="n">ub</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="n">cind0</span> <span class="o">=</span> <span class="n">cindf</span>
        <span class="k">for</span> <span class="n">constr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">linearConstr</span><span class="p">:</span>
            <span class="n">cindf</span> <span class="o">=</span> <span class="n">cind0</span> <span class="o">+</span> <span class="n">constr</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">clb</span><span class="p">[</span><span class="n">cind0</span><span class="p">:</span> <span class="n">cindf</span><span class="p">]</span> <span class="o">=</span> <span class="n">constr</span><span class="o">.</span><span class="n">lb</span>
            <span class="n">cub</span><span class="p">[</span><span class="n">cind0</span><span class="p">:</span> <span class="n">cindf</span><span class="p">]</span> <span class="o">=</span> <span class="n">constr</span><span class="o">.</span><span class="n">ub</span>
            <span class="n">cind0</span> <span class="o">=</span> <span class="n">cindf</span>
        <span class="c1"># the bounds for objaddn is 0 so we are good so far</span>
        <span class="c1"># assign to where it should belong to</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lb</span> <span class="o">=</span> <span class="n">clb</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ub</span> <span class="o">=</span> <span class="n">cub</span>

    <span class="k">def</span> <span class="nf">__getTimeGrid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Based on initial guess x, get the time grid for discretization.</span>

<span class="sd">        :param x: ndarray, the guess/sol.</span>
<span class="sd">        :returns: h: float, grid size</span>
<span class="sd">        :returns: useT: the grid being used</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixt0</span><span class="p">:</span>
            <span class="n">uset0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">uset0</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">t0ind</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixtf</span><span class="p">:</span>
            <span class="n">usetf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tf</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">usetf</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tfind</span><span class="p">]</span>
        <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">usetf</span> <span class="o">-</span> <span class="n">uset0</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">useT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">uset0</span><span class="p">,</span> <span class="n">usetf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">h</span><span class="p">,</span> <span class="n">useT</span>

    <span class="k">def</span> <span class="nf">__parseX__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Parse guess/sol into X, U, P&quot;&quot;&quot;</span>
        <span class="n">n_var_pnt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimu</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimp</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">*</span> <span class="n">n_var_pnt</span><span class="p">],</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">n_var_pnt</span><span class="p">))</span>
        <span class="n">useX</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span> <span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">dimx</span><span class="p">]</span>
        <span class="n">useU</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">dimpoint</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimp</span><span class="p">]</span>
        <span class="n">useP</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimpoint</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimp</span><span class="p">:]</span>
        <span class="k">return</span> <span class="n">useX</span><span class="p">,</span> <span class="n">useU</span><span class="p">,</span> <span class="n">useP</span>

<div class="viewcode-block" id="trajOptProblem.parseF"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptProblem.trajOptProblem.parseF">[docs]</a>    <span class="k">def</span> <span class="nf">parseF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">guess</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Give an guess, evaluate it and parse into parts.</span>

<span class="sd">        :param guess: ndarray, (numSol, ) a guess or a solution to check</span>
<span class="sd">        :returns: dict, containing objective and parsed constraints</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">guess</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">numSol</span>
        <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span>
        <span class="n">dimx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numF</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gradmode</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__callg__</span><span class="p">(</span><span class="n">guess</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__callf__</span><span class="p">(</span><span class="n">guess</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dynCon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">:(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">dimx</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dimx</span><span class="p">))</span>
        <span class="n">curN</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">dimx</span>
        <span class="n">pointCon</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">constr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointConstr</span><span class="p">:</span>
            <span class="n">pointCon</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">curN</span><span class="p">:</span> <span class="n">curN</span> <span class="o">+</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span><span class="p">])</span>
            <span class="n">curN</span> <span class="o">+=</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span>
        <span class="n">pathCon</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">constr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pathConstr</span><span class="p">:</span>
            <span class="n">pathCon</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">curN</span><span class="p">:</span> <span class="n">curN</span><span class="o">+</span><span class="n">N</span><span class="o">*</span><span class="n">constr</span><span class="o">.</span><span class="n">nf</span><span class="p">],</span> <span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span><span class="p">)))</span>
            <span class="n">curN</span> <span class="o">+=</span> <span class="n">N</span><span class="o">*</span><span class="n">constr</span><span class="o">.</span><span class="n">nf</span>
        <span class="n">nonLinCon</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">constr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonLinConstr</span><span class="p">:</span>
            <span class="n">nonLinCon</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">curN</span><span class="p">:</span> <span class="n">curN</span><span class="o">+</span><span class="n">constr</span><span class="o">.</span><span class="n">nf</span><span class="p">])</span>
            <span class="n">curN</span> <span class="o">+=</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span>
        <span class="c1"># check bounds, return a -1, 1 value for non-equality bounds, and 0 for equality bounds</span>
        <span class="n">useX</span><span class="p">,</span> <span class="n">useU</span><span class="p">,</span> <span class="n">useP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parseX__</span><span class="p">(</span><span class="n">guess</span><span class="p">)</span>
        <span class="n">Xbound</span> <span class="o">=</span> <span class="n">checkInBounds</span><span class="p">(</span><span class="n">useX</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xbd</span><span class="p">)</span>
        <span class="n">x0bound</span> <span class="o">=</span> <span class="n">checkInBounds</span><span class="p">(</span><span class="n">useX</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0bd</span><span class="p">)</span>
        <span class="n">xfbound</span> <span class="o">=</span> <span class="n">checkInBounds</span><span class="p">(</span><span class="n">useX</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">xfbd</span><span class="p">)</span>
        <span class="n">ubound</span> <span class="o">=</span> <span class="n">checkInBounds</span><span class="p">(</span><span class="n">useU</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ubd</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">pbound</span> <span class="o">=</span> <span class="n">checkInBounds</span><span class="p">(</span><span class="n">useP</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbd</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pbound</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0ind</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">t0bound</span> <span class="o">=</span> <span class="n">checkInBounds</span><span class="p">(</span><span class="n">guess</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">t0ind</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">t0bound</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tfind</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">tfbound</span> <span class="o">=</span> <span class="n">checkInBounds</span><span class="p">(</span><span class="n">guess</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tfind</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">tf</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tfbound</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lenAddX</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">addx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parseAddX__</span><span class="p">(</span><span class="n">guess</span><span class="p">)</span>
            <span class="n">addXbound</span> <span class="o">=</span> <span class="p">[</span><span class="n">checkInBounds</span><span class="p">(</span><span class="n">addx_</span><span class="p">,</span> <span class="p">[</span><span class="n">addx__</span><span class="o">.</span><span class="n">lb</span><span class="p">,</span> <span class="n">addx__</span><span class="o">.</span><span class="n">ub</span><span class="p">])</span> <span class="k">for</span> <span class="n">addx_</span><span class="p">,</span> <span class="n">addx__</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">addx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">addX</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">addXbound</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;obj&#39;</span><span class="p">:</span> <span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;dyn&#39;</span><span class="p">:</span> <span class="n">dynCon</span><span class="p">,</span> <span class="s1">&#39;point&#39;</span><span class="p">:</span> <span class="n">pointCon</span><span class="p">,</span> <span class="s1">&#39;path&#39;</span><span class="p">:</span> <span class="n">pathCon</span><span class="p">,</span> <span class="s1">&#39;nonlin&#39;</span><span class="p">:</span> <span class="n">nonLinCon</span><span class="p">,</span>
                <span class="s1">&#39;Xbd&#39;</span><span class="p">:</span> <span class="n">Xbound</span><span class="p">,</span> <span class="s1">&#39;Ubd&#39;</span><span class="p">:</span> <span class="n">ubound</span><span class="p">,</span> <span class="s1">&#39;x0bd&#39;</span><span class="p">:</span> <span class="n">x0bound</span><span class="p">,</span> <span class="s1">&#39;xfbd&#39;</span><span class="p">:</span> <span class="n">xfbound</span><span class="p">,</span> <span class="s1">&#39;Pbd&#39;</span><span class="p">:</span> <span class="n">pbound</span><span class="p">,</span>
                <span class="s1">&#39;t0bd&#39;</span><span class="p">:</span> <span class="n">t0bound</span><span class="p">,</span> <span class="s1">&#39;tfbd&#39;</span><span class="p">:</span> <span class="n">tfbound</span><span class="p">,</span> <span class="s1">&#39;addXbd&#39;</span><span class="p">:</span> <span class="n">addXbound</span><span class="p">}</span></div>

<div class="viewcode-block" id="trajOptProblem.parse_sol"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptProblem.trajOptProblem.parse_sol">[docs]</a>    <span class="k">def</span> <span class="nf">parse_sol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sol</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Call parseX function from utility and return a dict of solution.&quot;&quot;&quot;</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parseX__</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">P</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">h</span><span class="p">,</span> <span class="n">tgrid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_time_grid__</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parseObj__</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lenAddX</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;t&#39;</span><span class="p">:</span> <span class="n">tgrid</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span> <span class="s1">&#39;u&#39;</span><span class="p">:</span> <span class="n">U</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">:</span> <span class="n">P</span><span class="p">,</span> <span class="s1">&#39;obj&#39;</span><span class="p">:</span> <span class="n">obj</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;t&#39;</span><span class="p">:</span> <span class="n">tgrid</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span> <span class="s1">&#39;u&#39;</span><span class="p">:</span> <span class="n">U</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">:</span> <span class="n">P</span><span class="p">,</span> <span class="s1">&#39;addx&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parseAddX__</span><span class="p">(</span><span class="n">sol</span><span class="p">),</span> <span class="s1">&#39;obj&#39;</span><span class="p">:</span> <span class="n">obj</span><span class="p">}</span></div>

    <span class="k">def</span> <span class="nf">__get_time_grid__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Based on initial guess x, get the time grid for discretization.</span>

<span class="sd">        :param x: ndarray, the guess/sol.</span>
<span class="sd">        :returns: h: float, grid size</span>
<span class="sd">        :returns: useT: the grid being used</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixt0</span><span class="p">:</span>
            <span class="n">uset0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">uset0</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">t0ind</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixtf</span><span class="p">:</span>
            <span class="n">usetf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tf</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">usetf</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tfind</span><span class="p">]</span>
        <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">usetf</span> <span class="o">-</span> <span class="n">uset0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">useT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">uset0</span><span class="p">,</span> <span class="n">usetf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">h</span><span class="p">,</span> <span class="n">useT</span>

    <span class="k">def</span> <span class="nf">__parseObj__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">numSol</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">objaddn</span><span class="p">:]</span>

    <span class="k">def</span> <span class="nf">__parseAddX__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">numTraj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numTraj</span>
        <span class="n">addX</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">addx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">addX</span><span class="p">:</span>
            <span class="n">addX</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">numTraj</span><span class="p">:</span> <span class="n">numTraj</span> <span class="o">+</span> <span class="n">addx</span><span class="o">.</span><span class="n">n</span><span class="p">])</span>
            <span class="n">numTraj</span> <span class="o">+=</span> <span class="n">addx</span><span class="o">.</span><span class="n">n</span>
        <span class="k">return</span> <span class="n">addX</span>

<div class="viewcode-block" id="trajOptProblem.__callf__"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptProblem.trajOptProblem.__callf__">[docs]</a>    <span class="k">def</span> <span class="nf">__callf__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>  <span class="c1"># TODO: remove callf case</span>
        <span class="sd">&quot;&quot;&quot;Evaluate those constraints and objective functions.&quot;&quot;&quot;</span>
        <span class="n">h</span><span class="p">,</span> <span class="n">useT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__getTimeGrid</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">useX</span><span class="p">,</span> <span class="n">useU</span><span class="p">,</span> <span class="n">useP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parseX__</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="c1"># evaluate objective function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__objModeF__</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">useT</span><span class="p">,</span> <span class="n">useX</span><span class="p">,</span> <span class="n">useU</span><span class="p">,</span> <span class="n">useP</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="c1"># evaluate the system dynamics constraint</span>
        <span class="n">curRow</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">curRow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dynconstrModeF__</span><span class="p">(</span><span class="n">curRow</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">useT</span><span class="p">,</span> <span class="n">useX</span><span class="p">,</span> <span class="n">useU</span><span class="p">,</span> <span class="n">useP</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="c1"># evaluate other constraints</span>
        <span class="n">curRow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__constrModeF__</span><span class="p">(</span><span class="n">curRow</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">useT</span><span class="p">,</span> <span class="n">useX</span><span class="p">,</span> <span class="n">useU</span><span class="p">,</span> <span class="n">useP</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">curRow</span></div>

    <span class="k">def</span> <span class="nf">__objModeF__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">curRow</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">useT</span><span class="p">,</span> <span class="n">useX</span><span class="p">,</span> <span class="n">useU</span><span class="p">,</span> <span class="n">useP</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate objective function. F mode</span>

<span class="sd">        :param curRow: int, index from which we write on</span>
<span class="sd">        :param h, useT, useX, useU, useP: parsed solution</span>
<span class="sd">        :param x: ndarray, the sol, it is used for linear constraints</span>
<span class="sd">        :param y: ndarray, the F to be written. The first row stores the objective function</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">tmpout</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">linearObj</span><span class="p">:</span>
            <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">obj</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">linPointObj</span><span class="p">:</span>
            <span class="n">tmpx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="n">useT</span><span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">index</span><span class="p">]],</span> <span class="n">useX</span><span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">index</span><span class="p">],</span> <span class="n">useU</span><span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">index</span><span class="p">],</span> <span class="n">useP</span><span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">index</span><span class="p">]))</span>
            <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">obj</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">tmpx</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonLinObj</span><span class="p">:</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">__callf__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">tmpout</span><span class="p">)</span>
            <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">tmpout</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">linPathObj</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">tmpx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="n">useT</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">useX</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">useU</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">useP</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">__callf__</span><span class="p">(</span><span class="n">tmpx</span><span class="p">,</span> <span class="n">tmpout</span><span class="p">)</span>
                <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">tmpout</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">h</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonPointObj</span><span class="p">:</span>
            <span class="n">tmpx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="n">useT</span><span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">index</span><span class="p">]],</span> <span class="n">useX</span><span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">index</span><span class="p">],</span> <span class="n">useU</span><span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">index</span><span class="p">],</span> <span class="n">useP</span><span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">index</span><span class="p">]))</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">__callf__</span><span class="p">(</span><span class="n">tmpx</span><span class="p">,</span> <span class="n">tmpout</span><span class="p">)</span>
            <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">tmpout</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonPathObj</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">tmpx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="n">useT</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">useX</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">useU</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">useP</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">__callf__</span><span class="p">(</span><span class="n">tmpx</span><span class="p">,</span> <span class="n">tmpout</span><span class="p">)</span>
                <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">tmpout</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">h</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonLinObj</span><span class="p">:</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">__callf__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">tmpout</span><span class="p">)</span>
            <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">tmpout</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># add lqr cost, if applicable</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lqrObj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lqrObj</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">useX</span><span class="p">,</span> <span class="n">useU</span><span class="p">,</span> <span class="n">useP</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__constrModeF__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">curRow</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">useT</span><span class="p">,</span> <span class="n">useX</span><span class="p">,</span> <span class="n">useU</span><span class="p">,</span> <span class="n">useP</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate constraint function. F mode</span>

<span class="sd">        :param curRow: int, index from which we write on</span>
<span class="sd">        :param h, useT, useX, useU, useP: parsed solution</span>
<span class="sd">        :param y: ndarray, the F to be written</span>
<span class="sd">        :returns: curRow: current row after we write on y</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">constr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointConstr</span><span class="p">:</span>
            <span class="n">tmpx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="n">useT</span><span class="p">[</span><span class="n">constr</span><span class="o">.</span><span class="n">index</span><span class="p">]],</span> <span class="n">useX</span><span class="p">[</span><span class="n">constr</span><span class="o">.</span><span class="n">index</span><span class="p">],</span> <span class="n">useU</span><span class="p">[</span><span class="n">constr</span><span class="o">.</span><span class="n">index</span><span class="p">],</span> <span class="n">useP</span><span class="p">[</span><span class="n">constr</span><span class="o">.</span><span class="n">index</span><span class="p">]))</span>
            <span class="n">constr</span><span class="o">.</span><span class="n">__evalf__</span><span class="p">(</span><span class="n">tmpx</span><span class="p">,</span> <span class="n">y</span><span class="p">[</span><span class="n">curRow</span><span class="p">:</span> <span class="n">curRow</span> <span class="o">+</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span><span class="p">])</span>
            <span class="n">curRow</span> <span class="o">+=</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span>
        <span class="k">for</span> <span class="n">constr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pathConstr</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
                <span class="n">tmpx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="n">useT</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">useX</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">useU</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">useP</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                <span class="n">constr</span><span class="o">.</span><span class="n">__evalf__</span><span class="p">(</span><span class="n">tmpx</span><span class="p">,</span> <span class="n">y</span><span class="p">[</span><span class="n">curRow</span><span class="p">:</span> <span class="n">curRow</span> <span class="o">+</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">numFcurRow</span> <span class="o">+=</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span>
        <span class="k">for</span> <span class="n">constr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonLinConstr</span><span class="p">:</span>
            <span class="n">constr</span><span class="o">.</span><span class="n">__evalf__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">[</span><span class="n">curRow</span><span class="p">:</span> <span class="n">curRow</span> <span class="o">+</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span><span class="p">])</span>
            <span class="n">curRow</span> <span class="o">+=</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span>
        <span class="k">return</span> <span class="n">curRow</span>

    <span class="k">def</span> <span class="nf">__dynconstrModeF__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">curRow</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">useT</span><span class="p">,</span> <span class="n">useX</span><span class="p">,</span> <span class="n">useU</span><span class="p">,</span> <span class="n">useP</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate constraint from dynamics. F mode.</span>

<span class="sd">        :param curRow: int, index from which we write on</span>
<span class="sd">        :param h, useT, useX, useU, useP: the parsed sol</span>
<span class="sd">        :param y: ndarray, the F</span>
<span class="sd">        :returns: curRow: current row after we write on y</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># loop over all system dynamics constraint</span>
        <span class="n">cDyn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">curRow</span><span class="p">:</span><span class="n">curRow</span><span class="o">+</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span><span class="p">],</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># evaluate gradient of system dynamics</span>
            <span class="n">ydot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sys</span><span class="o">.</span><span class="n">dyn</span><span class="p">(</span><span class="n">useT</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">useX</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">useU</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">useP</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">cDyn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">useX</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span> <span class="o">*</span> <span class="n">ydot</span> <span class="o">-</span> <span class="n">useX</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">curRow</span>

<div class="viewcode-block" id="trajOptProblem.__callg__"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptProblem.trajOptProblem.__callg__">[docs]</a>    <span class="k">def</span> <span class="nf">__callg__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span> <span class="n">needg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate those constraints, objective functions, and constraints. It simultaneously allocates sparsity matrix.</span>

<span class="sd">        :param x: ndarray, the solution to the problem</span>
<span class="sd">        :param y: ndarray, return F</span>
<span class="sd">        :param G, row, col: ndarray, information of gradient</span>
<span class="sd">        :param rec, needg: if we record/ if we need gradient</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">h</span><span class="p">,</span> <span class="n">useT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__getTimeGrid</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">useX</span><span class="p">,</span> <span class="n">useU</span><span class="p">,</span> <span class="n">useP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parseX__</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="c1"># loop over all system dynamics constraint</span>
        <span class="n">curRow</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">curNg</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">curRow</span><span class="p">,</span> <span class="n">curNg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dynconstrModeG</span><span class="p">(</span><span class="n">curRow</span><span class="p">,</span> <span class="n">curNg</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">useT</span><span class="p">,</span> <span class="n">useX</span><span class="p">,</span> <span class="n">useU</span><span class="p">,</span> <span class="n">useP</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span> <span class="n">needg</span><span class="p">)</span>
        <span class="n">curRow</span><span class="p">,</span> <span class="n">curNg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__constrModeG</span><span class="p">(</span><span class="n">curRow</span><span class="p">,</span> <span class="n">curNg</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">useT</span><span class="p">,</span> <span class="n">useX</span><span class="p">,</span> <span class="n">useU</span><span class="p">,</span> <span class="n">useP</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span> <span class="n">needg</span><span class="p">)</span>
        <span class="n">curRow</span><span class="p">,</span> <span class="n">curNg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__objModeG</span><span class="p">(</span><span class="n">curRow</span><span class="p">,</span> <span class="n">curNg</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">useT</span><span class="p">,</span> <span class="n">useX</span><span class="p">,</span> <span class="n">useU</span><span class="p">,</span> <span class="n">useP</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span> <span class="n">needg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">curRow</span><span class="p">,</span> <span class="n">curNg</span></div>

    <span class="k">def</span> <span class="nf">__dynconstrModeG</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">curRow</span><span class="p">,</span> <span class="n">curNg</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">useT</span><span class="p">,</span> <span class="n">useX</span><span class="p">,</span> <span class="n">useU</span><span class="p">,</span> <span class="n">useP</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span> <span class="n">needg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate the constraints imposed by system dynamics&quot;&quot;&quot;</span>
        <span class="n">dimx</span><span class="p">,</span> <span class="n">dimu</span><span class="p">,</span> <span class="n">dimp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimp</span>
        <span class="n">numX</span><span class="p">,</span> <span class="n">numU</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numX</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numU</span>
        <span class="n">cDyn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">curRow</span><span class="p">:</span><span class="n">curRow</span><span class="o">+</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span><span class="p">],</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># evaluate gradient of system dynamics TODO: support other types of integration scheme</span>
            <span class="n">ydot</span><span class="p">,</span> <span class="n">Jac</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sys</span><span class="o">.</span><span class="n">Jdyn</span><span class="p">(</span><span class="n">useT</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">useX</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">useU</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">useP</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>  <span class="c1"># TODO: support in-place Jacobian</span>
            <span class="n">cDyn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">useX</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span> <span class="o">*</span> <span class="n">ydot</span> <span class="o">-</span> <span class="n">useX</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">needg</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynSparse</span><span class="p">:</span>
                    <span class="n">Jac</span> <span class="o">*=</span> <span class="n">h</span>  <span class="c1"># always useful</span>
                    <span class="c1"># assign a block for x</span>
                    <span class="n">G</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">dimx</span><span class="o">*</span><span class="n">dimx</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">Jac</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="o">+</span><span class="n">dimx</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">dimx</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">rec</span><span class="p">:</span>
                        <span class="n">tmpMat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dimx</span><span class="p">),</span> <span class="p">(</span><span class="n">dimx</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
                        <span class="n">row</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">dimx</span><span class="o">*</span><span class="n">dimx</span><span class="p">]</span> <span class="o">=</span> <span class="n">curRow</span> <span class="o">+</span> <span class="n">tmpMat</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                        <span class="n">col</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">dimx</span><span class="o">*</span><span class="n">dimx</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">dimx</span> <span class="o">+</span> <span class="n">tmpMat</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                    <span class="n">curNg</span> <span class="o">+=</span> <span class="n">dimx</span> <span class="o">*</span> <span class="n">dimx</span>
                    <span class="c1"># assign a block for u</span>
                    <span class="n">G</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">dimx</span><span class="o">*</span><span class="n">dimu</span><span class="p">]</span> <span class="o">=</span> <span class="n">Jac</span><span class="p">[:,</span> <span class="mi">1</span><span class="o">+</span><span class="n">dimx</span><span class="p">:</span><span class="mi">1</span><span class="o">+</span><span class="n">dimx</span><span class="o">+</span><span class="n">dimu</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">rec</span><span class="p">:</span>
                        <span class="n">row</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">dimx</span><span class="o">*</span><span class="n">dimu</span><span class="p">]</span> <span class="o">=</span> <span class="n">curRow</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dimx</span><span class="p">),</span> <span class="p">(</span><span class="n">dimu</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                        <span class="n">col</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">dimx</span><span class="o">*</span><span class="n">dimu</span><span class="p">]</span> <span class="o">=</span> <span class="n">numX</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">dimu</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dimu</span><span class="p">),</span> <span class="n">dimx</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                    <span class="n">curNg</span> <span class="o">+=</span> <span class="n">dimx</span> <span class="o">*</span> <span class="n">dimu</span>
                    <span class="c1"># assign a block for p, if necessary</span>
                    <span class="k">if</span> <span class="n">dimp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">G</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">dimx</span><span class="o">*</span><span class="n">dimp</span><span class="p">]</span> <span class="o">=</span> <span class="n">Jac</span><span class="p">[:,</span> <span class="mi">1</span><span class="o">+</span><span class="n">dimx</span><span class="o">+</span><span class="n">dimu</span><span class="p">:</span><span class="mi">1</span><span class="o">+</span><span class="n">dimx</span><span class="o">+</span><span class="n">dimu</span><span class="o">+</span><span class="n">dimp</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                        <span class="k">if</span> <span class="n">rec</span><span class="p">:</span>
                            <span class="n">row</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">dimx</span><span class="o">*</span><span class="n">dimp</span><span class="p">]</span> <span class="o">=</span> <span class="n">curRow</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dimx</span><span class="p">),</span> <span class="p">(</span><span class="n">dimp</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                            <span class="n">col</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">dimx</span><span class="o">*</span><span class="n">dimp</span><span class="p">]</span> <span class="o">=</span> <span class="n">numX</span> <span class="o">+</span> <span class="n">numU</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">dimp</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dimp</span><span class="p">),</span> <span class="n">dimx</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                        <span class="n">curNg</span> <span class="o">+=</span> <span class="n">dimx</span> <span class="o">*</span> <span class="n">dimp</span>
                    <span class="c1"># assign the diagonal block for x_{k+1}</span>
                    <span class="n">G</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">dimx</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
                    <span class="k">if</span> <span class="n">rec</span><span class="p">:</span>
                        <span class="n">row</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">dimx</span><span class="p">]</span> <span class="o">=</span> <span class="n">curRow</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dimx</span><span class="p">)</span>
                        <span class="n">col</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">dimx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">((</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">dimx</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">dimx</span><span class="p">)</span>
                    <span class="n">curNg</span> <span class="o">+=</span> <span class="n">dimx</span>
                    <span class="c1"># assign a column for t0, if necessary</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0ind</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">G</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">dimx</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">ydot</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">Jac</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">))</span>
                        <span class="k">if</span> <span class="n">rec</span><span class="p">:</span>
                            <span class="n">row</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">dimx</span><span class="p">]</span> <span class="o">=</span> <span class="n">curRow</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dimx</span><span class="p">)</span>
                            <span class="n">col</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">dimx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0ind</span>
                        <span class="n">curNg</span> <span class="o">+=</span> <span class="n">dimx</span>
                    <span class="c1"># assign a column for tf, if necessary</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tfind</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">G</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">dimx</span><span class="p">]</span> <span class="o">=</span> <span class="n">ydot</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">Jac</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">))</span>
                        <span class="k">if</span> <span class="n">rec</span><span class="p">:</span>
                            <span class="n">row</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">dimx</span><span class="p">]</span> <span class="o">=</span> <span class="n">curRow</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dimx</span><span class="p">)</span>
                            <span class="n">col</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">dimx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tfind</span>
                        <span class="n">curNg</span> <span class="o">+=</span> <span class="n">dimx</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">Jac</span><span class="o">.</span><span class="n">data</span> <span class="o">*=</span> <span class="n">h</span>  <span class="c1"># as always, no damage to this</span>
                    <span class="n">eyemat</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimx</span><span class="p">),</span> <span class="n">offsets</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">Jac</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                    <span class="n">Jac</span> <span class="o">+=</span> <span class="n">eyemat</span>  <span class="c1"># TODO: this assume forward Euler, backward needs update</span>
                    <span class="n">dynnnz</span> <span class="o">=</span> <span class="n">Jac</span><span class="o">.</span><span class="n">nnz</span> <span class="o">-</span> <span class="n">Jac</span><span class="o">.</span><span class="n">getcol</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">nnz</span>  <span class="c1"># TODO: this might cause serious issues since it changes structure</span>
                    <span class="c1"># convention is to assign all but first column, then assign first column</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">sparse</span><span class="o">.</span><span class="n">isspmatrix_coo</span><span class="p">(</span><span class="n">Jac</span><span class="p">):</span>
                        <span class="n">Jac</span> <span class="o">=</span> <span class="n">Jac</span><span class="o">.</span><span class="n">tocoo</span><span class="p">()</span>
                    <span class="n">rows</span> <span class="o">=</span> <span class="n">Jac</span><span class="o">.</span><span class="n">row</span>
                    <span class="n">cols</span> <span class="o">=</span> <span class="n">Jac</span><span class="o">.</span><span class="n">col</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">Jac</span><span class="o">.</span><span class="n">data</span>
                    <span class="n">timeone</span> <span class="o">=</span> <span class="n">cols</span> <span class="o">==</span> <span class="mi">0</span>
                    <span class="n">nontime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">timeone</span><span class="p">)</span>
                    <span class="n">G</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">dynnnz</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">nontime</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">rec</span><span class="p">:</span>
                        <span class="n">row</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">dynnnz</span><span class="p">]</span> <span class="o">=</span> <span class="n">curRow</span> <span class="o">+</span> <span class="n">rows</span><span class="p">[</span><span class="n">nontime</span><span class="p">]</span>
                        <span class="n">col</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">dynnnz</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__patchCol__</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">cols</span><span class="p">[</span><span class="n">nontime</span><span class="p">])</span>
                    <span class="n">curNg</span> <span class="o">+=</span> <span class="n">dynnnz</span>
                    <span class="c1"># for x_{k+1}</span>
                    <span class="n">G</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">dimx</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
                    <span class="k">if</span> <span class="n">rec</span><span class="p">:</span>
                        <span class="n">row</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">dimx</span><span class="p">]</span> <span class="o">=</span> <span class="n">curRow</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dimx</span><span class="p">)</span>
                        <span class="n">col</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">dimx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dimx</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimpoint</span>
                    <span class="n">curNg</span> <span class="o">+=</span> <span class="n">dimx</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0ind</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">G</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">dimx</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">ydot</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">Jac</span><span class="o">.</span><span class="n">getcol</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">toarray</span><span class="p">()[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">))</span>
                        <span class="k">if</span> <span class="n">rec</span><span class="p">:</span>
                            <span class="n">row</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">dimx</span><span class="p">]</span> <span class="o">=</span> <span class="n">curRow</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dimx</span><span class="p">)</span>
                            <span class="n">col</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">dimx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0ind</span>
                        <span class="n">curNg</span> <span class="o">+=</span> <span class="n">dimx</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tfind</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">G</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">dimx</span><span class="p">]</span> <span class="o">=</span> <span class="n">ydot</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">Jac</span><span class="o">.</span><span class="n">getcol</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">toarray</span><span class="p">()[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">))</span>
                        <span class="k">if</span> <span class="n">rec</span><span class="p">:</span>
                            <span class="n">row</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">dimx</span><span class="p">]</span> <span class="o">=</span> <span class="n">curRow</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dimx</span><span class="p">)</span>
                            <span class="n">col</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">dimx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tfind</span>
                        <span class="n">curNg</span> <span class="o">+=</span> <span class="n">dimx</span>
            <span class="n">curRow</span> <span class="o">+=</span> <span class="n">dimx</span>
        <span class="k">return</span> <span class="n">curRow</span><span class="p">,</span> <span class="n">curNg</span>

    <span class="k">def</span> <span class="nf">__objModeG</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">curRow</span><span class="p">,</span> <span class="n">curNg</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">useT</span><span class="p">,</span> <span class="n">useX</span><span class="p">,</span> <span class="n">useU</span><span class="p">,</span> <span class="n">useP</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span> <span class="n">needg</span><span class="p">,</span> <span class="n">first_row</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate objective function. It just evaluates them and assign to correct position in y.</span>

<span class="sd">        See __constr_mode_g__ for arguments and output.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tmpout</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">curRow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numF</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">objaddn</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lqrObj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># the lqr obj</span>
            <span class="n">Gpiece</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">LQRnG</span><span class="p">]</span>
            <span class="n">rowpiece</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">LQRnG</span><span class="p">]</span>
            <span class="n">colpiece</span> <span class="o">=</span> <span class="n">col</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">LQRnG</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lqrObj</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">useX</span><span class="p">,</span> <span class="n">useU</span><span class="p">,</span> <span class="n">useP</span><span class="p">,</span> <span class="n">tmpout</span><span class="p">,</span> <span class="n">Gpiece</span><span class="p">,</span> <span class="n">rowpiece</span><span class="p">,</span> <span class="n">colpiece</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span> <span class="n">needg</span><span class="p">)</span>
            <span class="n">y</span><span class="p">[</span><span class="n">curRow</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmpout</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">rec</span><span class="p">:</span>
                <span class="n">rowpiece</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">curRow</span>
            <span class="n">curNg</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LQRnG</span>
            <span class="n">curRow</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># still in the point, path, obj order</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonPointObj</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonPointObj</span><span class="p">:</span>
                <span class="n">tmpx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="n">useT</span><span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">index</span><span class="p">]],</span> <span class="n">useX</span><span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">index</span><span class="p">],</span> <span class="n">useU</span><span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">index</span><span class="p">],</span> <span class="n">useP</span><span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">index</span><span class="p">]))</span>
                <span class="n">Gpiece</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">obj</span><span class="o">.</span><span class="n">nG</span><span class="p">]</span>
                <span class="n">rowpiece</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">obj</span><span class="o">.</span><span class="n">nG</span><span class="p">]</span>
                <span class="n">colpiece</span> <span class="o">=</span> <span class="n">col</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">obj</span><span class="o">.</span><span class="n">nG</span><span class="p">]</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">__callg__</span><span class="p">(</span><span class="n">tmpx</span><span class="p">,</span> <span class="n">tmpout</span><span class="p">,</span> <span class="n">Gpiece</span><span class="p">,</span> <span class="n">rowpiece</span><span class="p">,</span> <span class="n">colpiece</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span> <span class="n">needg</span><span class="p">)</span>
                <span class="n">y</span><span class="p">[</span><span class="n">curRow</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmpout</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">rec</span><span class="p">:</span>
                    <span class="n">rowpiece</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">curRow</span>
                    <span class="n">colpiece</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__patchCol__</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">colpiece</span><span class="p">)</span>
                <span class="n">curNg</span> <span class="o">+=</span> <span class="n">obj</span><span class="o">.</span><span class="n">nG</span>
                <span class="n">curRow</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonPathObj</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonPathObj</span><span class="p">:</span>
                <span class="n">y</span><span class="p">[</span><span class="n">curRow</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">tmpx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="n">useT</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">useX</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">useU</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">useP</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                    <span class="n">Gpiece</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">obj</span><span class="o">.</span><span class="n">nG</span><span class="p">]</span>
                    <span class="n">rowpiece</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">obj</span><span class="o">.</span><span class="n">nG</span><span class="p">]</span>
                    <span class="n">colpiece</span> <span class="o">=</span> <span class="n">col</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">obj</span><span class="o">.</span><span class="n">nG</span><span class="p">]</span>
                    <span class="n">obj</span><span class="o">.</span><span class="n">__callg__</span><span class="p">(</span><span class="n">tmpx</span><span class="p">,</span> <span class="n">tmpout</span><span class="p">,</span> <span class="n">Gpiece</span><span class="p">,</span> <span class="n">rowpiece</span><span class="p">,</span> <span class="n">colpiece</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span> <span class="n">needg</span><span class="p">)</span>
                    <span class="n">y</span><span class="p">[</span><span class="n">curRow</span><span class="p">]</span> <span class="o">+=</span> <span class="n">tmpout</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">h</span>
                    <span class="n">Gpiece</span><span class="p">[:]</span> <span class="o">*=</span> <span class="n">h</span>
                    <span class="k">if</span> <span class="n">rec</span><span class="p">:</span>
                        <span class="n">rowpiece</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">curRow</span>
                        <span class="n">colpiece</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__patchCol__</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">colpiece</span><span class="p">)</span>
                    <span class="n">curNg</span> <span class="o">+=</span> <span class="n">obj</span><span class="o">.</span><span class="n">nG</span>
                <span class="n">curRow</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonLinObj</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonLinObj</span><span class="p">:</span>  <span class="c1"># nonlinear cost function</span>
                <span class="n">Gpiece</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">obj</span><span class="o">.</span><span class="n">nG</span><span class="p">]</span>
                <span class="n">rowpiece</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">obj</span><span class="o">.</span><span class="n">nG</span><span class="p">]</span>
                <span class="n">colpiece</span> <span class="o">=</span> <span class="n">col</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">obj</span><span class="o">.</span><span class="n">nG</span><span class="p">]</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">__callg__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">tmpout</span><span class="p">,</span> <span class="n">Gpiece</span><span class="p">,</span> <span class="n">rowpiece</span><span class="p">,</span> <span class="n">colpiece</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span> <span class="n">needg</span><span class="p">)</span>
                <span class="n">y</span><span class="p">[</span><span class="n">curRow</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmpout</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">rec</span><span class="p">:</span>
                    <span class="n">rowpiece</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">curRow</span>
                <span class="n">curNg</span> <span class="o">+=</span> <span class="n">obj</span><span class="o">.</span><span class="n">nG</span>
                <span class="n">curRow</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">curRow</span><span class="p">,</span> <span class="n">curNg</span>

    <span class="k">def</span> <span class="nf">__constrModeG</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">curRow</span><span class="p">,</span> <span class="n">curNg</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">useT</span><span class="p">,</span> <span class="n">useX</span><span class="p">,</span> <span class="n">useU</span><span class="p">,</span> <span class="n">useP</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span> <span class="n">needg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate constraint function. G mode</span>

<span class="sd">        :param curRow: int, index from which we write on</span>
<span class="sd">        :param curNg: int, current index in G</span>
<span class="sd">        :param h, useT, useX, useU, useP: parsed solution</span>
<span class="sd">        :param y: ndarray, the F to be written</span>
<span class="sd">        :param G, row, col: ndarray, the G to be written and the locations</span>
<span class="sd">        :param rec: bool, if we record row and col</span>
<span class="sd">        :param needg: bool, if we need gradient information</span>
<span class="sd">        :return curRow: current row after we write on y</span>
<span class="sd">        :return curNg: current index in G after this</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># loop over other constraints</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pointConstr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">constr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointConstr</span><span class="p">:</span>
                <span class="n">tmpx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="n">useT</span><span class="p">[</span><span class="n">constr</span><span class="o">.</span><span class="n">index</span><span class="p">]],</span> <span class="n">useX</span><span class="p">[</span><span class="n">constr</span><span class="o">.</span><span class="n">index</span><span class="p">],</span> <span class="n">useU</span><span class="p">[</span><span class="n">constr</span><span class="o">.</span><span class="n">index</span><span class="p">],</span> <span class="n">useP</span><span class="p">[</span><span class="n">constr</span><span class="o">.</span><span class="n">index</span><span class="p">]))</span>
                <span class="n">pieceG</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">constr</span><span class="o">.</span><span class="n">nG</span><span class="p">]</span>
                <span class="n">pieceRow</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">constr</span><span class="o">.</span><span class="n">nG</span><span class="p">]</span>
                <span class="n">pieceCol</span> <span class="o">=</span> <span class="n">col</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">constr</span><span class="o">.</span><span class="n">nG</span><span class="p">]</span>
                <span class="n">constr</span><span class="o">.</span><span class="n">__callg__</span><span class="p">(</span><span class="n">tmpx</span><span class="p">,</span> <span class="n">y</span><span class="p">[</span><span class="n">curRow</span><span class="p">:</span> <span class="n">curRow</span> <span class="o">+</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span><span class="p">],</span> <span class="n">pieceG</span><span class="p">,</span> <span class="n">pieceRow</span><span class="p">,</span> <span class="n">pieceCol</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span> <span class="n">needg</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">rec</span><span class="p">:</span>
                    <span class="n">pieceRow</span> <span class="o">+=</span> <span class="n">curRow</span>
                    <span class="n">pieceCol</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__patchCol__</span><span class="p">(</span><span class="n">constr</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">pieceCol</span><span class="p">)</span>
                <span class="n">curRow</span> <span class="o">+=</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span>
                <span class="n">curNg</span> <span class="o">+=</span> <span class="n">constr</span><span class="o">.</span><span class="n">nG</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pathConstr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">constr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pathConstr</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
                    <span class="n">tmpx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="n">useT</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">useX</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">useU</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">useP</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                    <span class="n">pieceG</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">constr</span><span class="o">.</span><span class="n">nG</span><span class="p">]</span>
                    <span class="n">pieceRow</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">constr</span><span class="o">.</span><span class="n">nG</span><span class="p">]</span>
                    <span class="n">pieceCol</span> <span class="o">=</span> <span class="n">col</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">constr</span><span class="o">.</span><span class="n">nG</span><span class="p">]</span>
                    <span class="n">constr</span><span class="o">.</span><span class="n">__callg__</span><span class="p">(</span><span class="n">tmpx</span><span class="p">,</span> <span class="n">y</span><span class="p">[</span><span class="n">curRow</span><span class="p">:</span> <span class="n">curRow</span> <span class="o">+</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span><span class="p">],</span> <span class="n">pieceG</span><span class="p">,</span> <span class="n">pieceRow</span><span class="p">,</span> <span class="n">pieceCol</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span> <span class="n">needg</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">rec</span><span class="p">:</span>
                        <span class="n">pieceRow</span> <span class="o">+=</span> <span class="n">curRow</span>
                        <span class="n">pieceCol</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__patchCol__</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">pieceCol</span><span class="p">)</span>
                    <span class="n">curRow</span> <span class="o">+=</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span>
                    <span class="n">curNg</span> <span class="o">+=</span> <span class="n">constr</span><span class="o">.</span><span class="n">nG</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonLinConstr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">constr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonLinConstr</span><span class="p">:</span>
                <span class="n">pieceG</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">constr</span><span class="o">.</span><span class="n">nG</span><span class="p">]</span>
                <span class="n">pieceRow</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">constr</span><span class="o">.</span><span class="n">nG</span><span class="p">]</span>
                <span class="n">pieceCol</span> <span class="o">=</span> <span class="n">col</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">constr</span><span class="o">.</span><span class="n">nG</span><span class="p">]</span>
                <span class="n">constr</span><span class="o">.</span><span class="n">__callg__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">[</span><span class="n">curRow</span><span class="p">:</span> <span class="n">curRow</span> <span class="o">+</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span><span class="p">],</span> <span class="n">pieceG</span><span class="p">,</span> <span class="n">pieceRow</span><span class="p">,</span> <span class="n">pieceCol</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span> <span class="n">needg</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">rec</span><span class="p">:</span>
                    <span class="n">pieceRow</span> <span class="o">+=</span> <span class="n">curRow</span>
                <span class="n">curRow</span> <span class="o">+=</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span>
                <span class="n">curNg</span> <span class="o">+=</span> <span class="n">constr</span><span class="o">.</span><span class="n">nG</span>
        <span class="k">return</span> <span class="n">curRow</span><span class="p">,</span> <span class="n">curNg</span>

    <span class="c1"># interface functions for ipopt</span>
<div class="viewcode-block" id="trajOptProblem.ipEvalF"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptProblem.trajOptProblem.ipEvalF">[docs]</a>    <span class="k">def</span> <span class="nf">ipEvalF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The eval_f function required by ipopt.</span>

<span class="sd">        :param x: a guess/solution of the problem</span>
<span class="sd">        :return f: float, objective function</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">h</span><span class="p">,</span> <span class="n">useT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__getTimeGrid</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">useX</span><span class="p">,</span> <span class="n">useU</span><span class="p">,</span> <span class="n">useP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parseX__</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__objModeF__</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">useT</span><span class="p">,</span> <span class="n">useX</span><span class="p">,</span> <span class="n">useU</span><span class="p">,</span> <span class="n">useP</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">__cost__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Enter cost&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ipEvalF</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<div class="viewcode-block" id="trajOptProblem.ipEvalGradF"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptProblem.trajOptProblem.ipEvalGradF">[docs]</a>    <span class="k">def</span> <span class="nf">ipEvalGradF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluation of the gradient of objective function.</span>

<span class="sd">        :param x: guess/solution to the problem</span>
<span class="sd">        :return grad: gradient of objective function w.r.t x</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tmpG</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numSol</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Arow</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="n">tmpG</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">Acol</span><span class="p">[</span><span class="n">mask</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Aval</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">tmpG</span></div>

    <span class="k">def</span> <span class="nf">__gradient__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Enter gradient&quot;</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Arow</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="n">g</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">Acol</span><span class="p">[</span><span class="n">mask</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Aval</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        <span class="k">return</span> <span class="kc">True</span>

<div class="viewcode-block" id="trajOptProblem.ipEvalG"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptProblem.trajOptProblem.ipEvalG">[docs]</a>    <span class="k">def</span> <span class="nf">ipEvalG</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluation of the constraint function.</span>

<span class="sd">        :param x: ndarray, guess/solution to the problem.</span>
<span class="sd">        :return g: constraint function</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numF</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gradmode</span><span class="p">:</span>
            <span class="n">G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__callg__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">y</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__callf__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">y</span></div>

    <span class="k">def</span> <span class="nf">__constraint__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Enter constraint&quot;</span><span class="p">)</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__callg__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span>

<div class="viewcode-block" id="trajOptProblem.ipEvalJacG"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptProblem.trajOptProblem.ipEvalJacG">[docs]</a>    <span class="k">def</span> <span class="nf">ipEvalJacG</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">flag</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate jacobian of constraints. I simply call __callg__</span>

<span class="sd">        :param x: ndarray, guess / solution to the problem</span>
<span class="sd">        :param flag: bool, True return row/col, False return values</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numF</span><span class="p">)</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nG</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">flag</span><span class="p">:</span>
            <span class="n">row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nG</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nG</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__callg__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__callg__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">G</span></div>

    <span class="k">def</span> <span class="nf">__jacobian__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">rec</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Enter Jacobian&quot;</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numF</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__callg__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">__patchCol__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">col_offset</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find which indices it belongs to the original one for a local matrix at col&quot;&quot;&quot;</span>
        <span class="n">col</span> <span class="o">=</span> <span class="n">col</span><span class="p">[</span><span class="n">col</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span>
        <span class="k">return</span> <span class="n">col</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">col_offset</span> <span class="o">+</span> <span class="n">index</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimpoint</span>

<div class="viewcode-block" id="trajOptProblem.parseSol"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptProblem.trajOptProblem.parseSol">[docs]</a>    <span class="k">def</span> <span class="nf">parseSol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sol</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Call parseX function from utility and return a dict of solution.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">parseX</span><span class="p">(</span><span class="n">sol</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tf</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="trajOptProblem.addLQRObj"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptProblem.trajOptProblem.addLQRObj">[docs]</a>    <span class="k">def</span> <span class="nf">addLQRObj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lqrobj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a lqr objective function to the problem. It changes lqrObj into a function being called in two modes...</span>

<span class="sd">        :param lqrobj: a lqrObj class.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Fcol</span> <span class="o">=</span> <span class="n">lqrobj</span><span class="o">.</span><span class="n">F</span><span class="o">.</span><span class="n">col</span>
        <span class="n">Qcol</span> <span class="o">=</span> <span class="n">lqrobj</span><span class="o">.</span><span class="n">Q</span><span class="o">.</span><span class="n">col</span>
        <span class="n">Rcol</span> <span class="o">=</span> <span class="n">lqrobj</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">col</span>
        <span class="n">useF</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Fcol</span><span class="p">)</span>
        <span class="n">useQ</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Qcol</span><span class="p">)</span>
        <span class="n">useR</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Rcol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lqrobj</span><span class="o">.</span><span class="n">P</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Pcol</span> <span class="o">=</span> <span class="n">lqrobj</span><span class="o">.</span><span class="n">P</span><span class="o">.</span><span class="n">col</span>
            <span class="n">useP</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Pcol</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">useP</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">Pcol</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">lqrobj</span><span class="o">.</span><span class="n">tfweight</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tfweight</span> <span class="o">=</span> <span class="n">lqrobj</span><span class="o">.</span><span class="n">tfweight</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tfweight</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">LQRnG</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">useQ</span> <span class="o">+</span> <span class="n">useR</span> <span class="o">+</span> <span class="n">useP</span><span class="p">)</span> <span class="o">+</span> <span class="n">useF</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">numT</span>
        <span class="n">num1</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">useQ</span> <span class="o">+</span> <span class="n">useR</span> <span class="o">+</span> <span class="n">useP</span><span class="p">)</span>
        <span class="n">baseCol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimpoint</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>  <span class="c1"># a nPoint by 1 column matrix</span>

        <span class="k">def</span> <span class="nf">__callf__</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">useX</span><span class="p">,</span> <span class="n">useU</span><span class="p">,</span> <span class="n">useP_</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Calculate the lqr cost.</span>

<span class="sd">            :param h: float, grid size</span>
<span class="sd">            :param useX: ndarray, parsed X</span>
<span class="sd">            :param useU: ndarray, parsed U</span>
<span class="sd">            :param useP: ndarray, parsed P, might be empty</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">useF</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">y</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">lqrobj</span><span class="o">.</span><span class="n">F</span><span class="o">.</span><span class="n">data</span> <span class="o">*</span> <span class="p">((</span><span class="n">useX</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Fcol</span><span class="p">]</span> <span class="o">-</span> <span class="n">lqrobj</span><span class="o">.</span><span class="n">xfbase</span><span class="p">[</span><span class="n">Fcol</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">useQ</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">y</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">lqrobj</span><span class="o">.</span><span class="n">Q</span><span class="o">.</span><span class="n">data</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">useX</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Qcol</span><span class="p">]</span> <span class="o">-</span> <span class="n">lqrobj</span><span class="o">.</span><span class="n">xbase</span><span class="p">[</span><span class="n">Qcol</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span> <span class="o">*</span> <span class="n">h</span>
            <span class="k">if</span> <span class="n">useR</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">y</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">lqrobj</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">data</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">useU</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Rcol</span><span class="p">]</span> <span class="o">-</span> <span class="n">lqrobj</span><span class="o">.</span><span class="n">ubase</span><span class="p">[</span><span class="n">Rcol</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span> <span class="o">*</span> <span class="n">h</span>
            <span class="k">if</span> <span class="n">useP</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">y</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">lqrobj</span><span class="o">.</span><span class="n">P</span><span class="o">.</span><span class="n">data</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">useP_</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Pcol</span><span class="p">]</span> <span class="o">-</span> <span class="n">lqrobj</span><span class="o">.</span><span class="n">pbase</span><span class="p">[</span><span class="n">Pcol</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span> <span class="o">*</span> <span class="n">h</span>
            <span class="n">y</span> <span class="o">+=</span> <span class="n">tfweight</span> <span class="o">*</span> <span class="p">(</span><span class="n">h</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">y</span>

        <span class="k">def</span> <span class="nf">__callg__</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">useX</span><span class="p">,</span> <span class="n">useU</span><span class="p">,</span> <span class="n">useP_</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span> <span class="n">needg</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Calculate the lqr cost with gradient information.</span>

<span class="sd">            :param h: float, grid size</span>
<span class="sd">            :param useX, useU, useP: ndarray, parsed X, U, P from x, the same with __call__F</span>
<span class="sd">            :param y: ndarray, a location to write the objective function onto</span>
<span class="sd">            :param G, row, col: the gradient information</span>
<span class="sd">            :param rec: if we record row and col</span>
<span class="sd">            :param needg: if we need gradient information.</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">rec</span><span class="p">:</span>
                <span class="n">row</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">col_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">col</span><span class="p">[:</span><span class="n">num1</span><span class="p">],</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">needg</span><span class="p">:</span>
                <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">__callf__</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">useX</span><span class="p">,</span> <span class="n">useU</span><span class="p">,</span> <span class="n">useP_</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">yF</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">yQ</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">yR</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">yP</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">yTf</span> <span class="o">=</span> <span class="n">tfweight</span> <span class="o">*</span> <span class="p">(</span><span class="n">h</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">curG</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">G_</span> <span class="o">=</span> <span class="n">G</span><span class="p">[:</span><span class="n">num1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">useQ</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">yQ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">lqrobj</span><span class="o">.</span><span class="n">Q</span><span class="o">.</span><span class="n">data</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">useX</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Qcol</span><span class="p">]</span> <span class="o">-</span> <span class="n">lqrobj</span><span class="o">.</span><span class="n">xbase</span><span class="p">[</span><span class="n">Qcol</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span> <span class="o">*</span> <span class="n">h</span>
                    <span class="n">G_</span><span class="p">[:,</span> <span class="p">:</span><span class="n">useQ</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">h</span> <span class="o">*</span> <span class="p">((</span><span class="n">useX</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Qcol</span><span class="p">]</span> <span class="o">-</span> <span class="n">lqrobj</span><span class="o">.</span><span class="n">xbase</span><span class="p">[</span><span class="n">Qcol</span><span class="p">])</span> <span class="o">*</span> <span class="n">lqrobj</span><span class="o">.</span><span class="n">Q</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">rec</span><span class="p">:</span>
                        <span class="n">col_</span><span class="p">[:,</span> <span class="p">:</span><span class="n">useQ</span><span class="p">]</span> <span class="o">=</span> <span class="n">Qcol</span> <span class="o">+</span> <span class="n">baseCol</span>
                    <span class="n">curG</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">useQ</span>
                <span class="k">if</span> <span class="n">useR</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">yR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">lqrobj</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">data</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">useU</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Rcol</span><span class="p">]</span> <span class="o">-</span> <span class="n">lqrobj</span><span class="o">.</span><span class="n">ubase</span><span class="p">[</span><span class="n">Rcol</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span> <span class="o">*</span> <span class="n">h</span>
                    <span class="n">G_</span><span class="p">[:,</span> <span class="n">useQ</span><span class="p">:</span> <span class="n">useQ</span> <span class="o">+</span> <span class="n">useR</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">h</span> <span class="o">*</span> <span class="p">((</span><span class="n">useU</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Rcol</span><span class="p">]</span> <span class="o">-</span> <span class="n">lqrobj</span><span class="o">.</span><span class="n">ubase</span><span class="p">[</span><span class="n">Rcol</span><span class="p">])</span> <span class="o">*</span> <span class="n">lqrobj</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">rec</span><span class="p">:</span>
                        <span class="n">col_</span><span class="p">[:,</span> <span class="n">useQ</span><span class="p">:</span> <span class="n">useQ</span> <span class="o">+</span> <span class="n">useR</span><span class="p">]</span> <span class="o">=</span> <span class="n">Rcol</span> <span class="o">+</span> <span class="n">baseCol</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span>
                    <span class="n">curG</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">useR</span>
                <span class="k">if</span> <span class="n">useP</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">yP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">lqrobj</span><span class="o">.</span><span class="n">P</span><span class="o">.</span><span class="n">data</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">useP_</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Pcol</span><span class="p">]</span> <span class="o">-</span> <span class="n">lqrobj</span><span class="o">.</span><span class="n">pbase</span><span class="p">[</span><span class="n">Pcol</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span> <span class="o">*</span> <span class="n">h</span>
                    <span class="n">G_</span><span class="p">[:,</span> <span class="n">useQ</span> <span class="o">+</span> <span class="n">useR</span><span class="p">:</span> <span class="n">useQ</span> <span class="o">+</span> <span class="n">useR</span> <span class="o">+</span> <span class="n">useP</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">h</span> <span class="o">*</span> <span class="p">(</span><span class="n">useP_</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Pcol</span><span class="p">]</span> <span class="o">-</span> <span class="n">lqrobj</span><span class="o">.</span><span class="n">pbase</span><span class="p">[</span><span class="n">Pcol</span><span class="p">])</span> <span class="o">*</span> <span class="n">lqrobj</span><span class="o">.</span><span class="n">P</span><span class="o">.</span><span class="n">data</span>
                    <span class="k">if</span> <span class="n">rec</span><span class="p">:</span>
                        <span class="n">col_</span><span class="p">[:,</span> <span class="n">useQ</span> <span class="o">+</span> <span class="n">useR</span><span class="p">:</span> <span class="n">useQ</span> <span class="o">+</span> <span class="n">useR</span> <span class="o">+</span> <span class="n">useP</span><span class="p">]</span> <span class="o">=</span> <span class="n">Pcol</span> <span class="o">+</span> <span class="n">baseCol</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimu</span>
                    <span class="n">curG</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">useP</span>
                <span class="k">if</span> <span class="n">useF</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">yF</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">lqrobj</span><span class="o">.</span><span class="n">F</span><span class="o">.</span><span class="n">data</span> <span class="o">*</span> <span class="p">((</span><span class="n">useX</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Fcol</span><span class="p">]</span> <span class="o">-</span> <span class="n">lqrobj</span><span class="o">.</span><span class="n">xfbase</span><span class="p">[</span><span class="n">Fcol</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
                    <span class="n">G</span><span class="p">[</span><span class="n">curG</span><span class="p">:</span> <span class="n">curG</span> <span class="o">+</span> <span class="n">useF</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">lqrobj</span><span class="o">.</span><span class="n">F</span><span class="o">.</span><span class="n">data</span> <span class="o">*</span> <span class="p">(</span><span class="n">useX</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Fcol</span><span class="p">]</span> <span class="o">-</span> <span class="n">lqrobj</span><span class="o">.</span><span class="n">xfbase</span><span class="p">[</span><span class="n">Fcol</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">rec</span><span class="p">:</span>
                        <span class="n">col</span><span class="p">[</span><span class="n">curG</span><span class="p">:</span> <span class="n">curG</span> <span class="o">+</span> <span class="n">useF</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numX</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numX</span><span class="p">)</span>
                    <span class="n">curG</span> <span class="o">+=</span> <span class="n">useF</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0ind</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">G</span><span class="p">[</span><span class="n">curG</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">yQ</span> <span class="o">+</span> <span class="n">yR</span> <span class="o">+</span> <span class="n">yP</span><span class="p">)</span> <span class="o">/</span> <span class="n">h</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">tfweight</span>
                    <span class="k">if</span> <span class="n">rec</span><span class="p">:</span>
                        <span class="n">col</span><span class="p">[</span><span class="n">curG</span><span class="p">:</span> <span class="n">curG</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0ind</span>
                    <span class="n">curG</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tfind</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">G</span><span class="p">[</span><span class="n">curG</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">yQ</span> <span class="o">+</span> <span class="n">yR</span> <span class="o">+</span> <span class="n">yP</span><span class="p">)</span> <span class="o">/</span> <span class="n">h</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">tfweight</span>
                    <span class="k">if</span> <span class="n">rec</span><span class="p">:</span>
                        <span class="n">col</span><span class="p">[</span><span class="n">curG</span><span class="p">:</span> <span class="n">curG</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tfind</span>
                    <span class="n">curG</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">yF</span> <span class="o">+</span> <span class="n">yQ</span> <span class="o">+</span> <span class="n">yR</span> <span class="o">+</span> <span class="n">yP</span> <span class="o">+</span> <span class="n">yTf</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gradmode</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lqrObj</span> <span class="o">=</span> <span class="n">__callg__</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lqrObj</span> <span class="o">=</span> <span class="n">__callf__</span></div>

<div class="viewcode-block" id="trajOptProblem.addLinearObj"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptProblem.trajOptProblem.addLinearObj">[docs]</a>    <span class="k">def</span> <span class="nf">addLinearObj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linObj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add linear objective function.</span>

<span class="sd">        :param linObj: linearObj class</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">linObj</span><span class="p">,</span> <span class="n">linearObj</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linearObj</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">linObj</span><span class="p">)</span></div>

<div class="viewcode-block" id="trajOptProblem.addLinearPointObj"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptProblem.trajOptProblem.addLinearPointObj">[docs]</a>    <span class="k">def</span> <span class="nf">addLinearPointObj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linPointObj</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add linear point objective function.</span>

<span class="sd">        :param linPointObj: linearPointObj class</span>
<span class="sd">        :param path: bool, if this is path obj (at every point except for final one)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">linPointObj</span><span class="p">,</span> <span class="n">linearPointObj</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">path</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">linPathObj</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">linPointObj</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">linPointObj</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">linPointObj</span><span class="p">)</span></div>

<div class="viewcode-block" id="trajOptProblem.addNonLinearObj"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptProblem.trajOptProblem.addNonLinearObj">[docs]</a>    <span class="k">def</span> <span class="nf">addNonLinearObj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nonlinObj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add nonlinear objective function.</span>

<span class="sd">        :param nonLinObj: a nonLinObj class</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nonlinObj</span><span class="p">,</span> <span class="n">nonLinearObj</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonLinObj</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nonlinObj</span><span class="p">)</span></div>

<div class="viewcode-block" id="trajOptProblem.addNonLinearPointObj"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptProblem.trajOptProblem.addNonLinearPointObj">[docs]</a>    <span class="k">def</span> <span class="nf">addNonLinearPointObj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nonPntObj</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add nonlinear point objective.</span>

<span class="sd">        :param nonPntObj: nonLinObj class</span>
<span class="sd">        :param path: bool, if this obj is pointwise</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nonPntObj</span><span class="p">,</span> <span class="n">nonLinearPointObj</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">path</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nonPathObj</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nonPntObj</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nonPointObj</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nonPntObj</span><span class="p">)</span></div>

<div class="viewcode-block" id="trajOptProblem.addNonLinearPointConstr"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptProblem.trajOptProblem.addNonLinearPointConstr">[docs]</a>    <span class="k">def</span> <span class="nf">addNonLinearPointConstr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pntConstr</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add point constraint.</span>

<span class="sd">        :param pntConstr: pointConstr class</span>
<span class="sd">        :param path: bool, if this obj</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pntConstr</span><span class="p">,</span> <span class="n">nonLinearPointConstr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">path</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pathConstr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pntConstr</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pointConstr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pntConstr</span><span class="p">)</span></div>

<div class="viewcode-block" id="trajOptProblem.addNonLinearConstr"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptProblem.trajOptProblem.addNonLinearConstr">[docs]</a>    <span class="k">def</span> <span class="nf">addNonLinearConstr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a general nonlinear constraint.</span>

<span class="sd">        :param constr: nonLinConstr class</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">constr</span><span class="p">,</span> <span class="n">nonLinearConstr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonLinConstr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">constr</span><span class="p">)</span></div>

<div class="viewcode-block" id="trajOptProblem.addLinearConstr"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptProblem.trajOptProblem.addLinearConstr">[docs]</a>    <span class="k">def</span> <span class="nf">addLinearConstr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constr</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">constr</span><span class="p">,</span> <span class="n">linearConstr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linearConstr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">constr</span><span class="p">)</span></div>

<div class="viewcode-block" id="trajOptProblem.addLinearPointConstr"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptProblem.trajOptProblem.addLinearPointConstr">[docs]</a>    <span class="k">def</span> <span class="nf">addLinearPointConstr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constr</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">constr</span><span class="p">,</span> <span class="n">linearPointConstr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">path</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">linPathConstr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">constr</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">linPointConstr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">constr</span><span class="p">)</span></div>

<div class="viewcode-block" id="trajOptProblem.addObj"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptProblem.trajOptProblem.addObj">[docs]</a>    <span class="k">def</span> <span class="nf">addObj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A high level function that add objective function of any kind.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">linearObj</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addLinearObj</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">linearPointObj</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addLinearPointObj</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">nonLinearObj</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addNonLinearObj</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">nonLinearPointObj</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addNonLinearPointObj</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">lqrObj</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addLQRObj</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span></div>

<div class="viewcode-block" id="trajOptProblem.addConstr"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptProblem.trajOptProblem.addConstr">[docs]</a>    <span class="k">def</span> <span class="nf">addConstr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constr</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">constr</span><span class="p">,</span> <span class="n">linearConstr</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addLinearConstr</span><span class="p">(</span><span class="n">constr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">constr</span><span class="p">,</span> <span class="n">linearPointConstr</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addLinearPointConstr</span><span class="p">(</span><span class="n">constr</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">constr</span><span class="p">,</span> <span class="n">nonLinearConstr</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addNonLinearConstr</span><span class="p">(</span><span class="n">constr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">constr</span><span class="p">,</span> <span class="n">nonLinearPointConstr</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addNonLinearPointConstr</span><span class="p">(</span><span class="n">constr</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span></div>

<div class="viewcode-block" id="trajOptProblem.setN"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptProblem.trajOptProblem.setN">[docs]</a>    <span class="k">def</span> <span class="nf">setN</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set N.</span>

<span class="sd">        :param N: the size of discretization.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="n">N</span></div>

<div class="viewcode-block" id="trajOptProblem.sett0tf"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptProblem.trajOptProblem.sett0tf">[docs]</a>    <span class="k">def</span> <span class="nf">sett0tf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">tf</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set t0 and tf.</span>

<span class="sd">        :param t0: float/ndarray (2,) allowable t0</span>
<span class="sd">        :param tf: float/ndarray (2,) allowable tf</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t0</span> <span class="o">=</span> <span class="n">t0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tf</span> <span class="o">=</span> <span class="n">tf</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">tf</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fixtf</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fixtf</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">assert</span> <span class="n">tf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">tf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">t0</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fixt0</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fixt0</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">assert</span> <span class="n">t0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">t0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Gao Tang

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    

  

  <script type="text/javascript" src="../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>