

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>trajOptLib.trajOptCollocationProblem &mdash; trajoptlib  documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> trajoptlib
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <!-- Local TOC -->
              <div class="local-toc"></div>
            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">trajoptlib</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>trajOptLib.trajOptCollocationProblem</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for trajOptLib.trajOptCollocationProblem</h1><div class="highlight"><pre>
<span></span><span class="ch">#! /usr/bin/env python</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1"># vim:fenc=utf-8</span>
<span class="c1">#</span>
<span class="c1"># Copyright Â© 2018 Gao Tang &lt;gt70@duke.edu&gt;</span>
<span class="c1">#</span>
<span class="c1"># Distributed under terms of the MIT license.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">trajOptCollocationProblem.py</span>

<span class="sd">This class implements the direct collocation approach for humanoid trajectory optimization</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="k">import</span> <span class="n">interp1d</span>
<span class="kn">from</span> <span class="nn">.trajOptBase</span> <span class="k">import</span> <span class="n">linearObj</span><span class="p">,</span> <span class="n">linearPointObj</span>
<span class="kn">from</span> <span class="nn">.trajOptBase</span> <span class="k">import</span> <span class="n">linearPointConstr</span><span class="p">,</span> <span class="n">linearConstr</span>
<span class="kn">from</span> <span class="nn">.trajOptBase</span> <span class="k">import</span> <span class="n">nonLinearPointObj</span><span class="p">,</span> <span class="n">nonLinearObj</span>
<span class="kn">from</span> <span class="nn">.trajOptBase</span> <span class="k">import</span> <span class="n">nonLinearPointConstr</span><span class="p">,</span> <span class="n">nonLinearConstr</span>
<span class="kn">from</span> <span class="nn">.trajOptBase</span> <span class="k">import</span> <span class="n">lqrObj</span><span class="p">,</span> <span class="n">quadPenalty</span>
<span class="kn">from</span> <span class="nn">.trajOptBase</span> <span class="k">import</span> <span class="n">addX</span>
<span class="kn">from</span> <span class="nn">.trajOptBase</span> <span class="k">import</span> <span class="n">daeSystem</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">SnoptConfig</span><span class="p">,</span> <span class="n">probFun</span><span class="p">,</span> <span class="n">solver</span>
<span class="kn">from</span> <span class="nn">.utility</span> <span class="k">import</span> <span class="n">randomGenInBound</span><span class="p">,</span> <span class="n">checkInBounds</span><span class="p">,</span> <span class="n">interp</span>
<span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="k">import</span> <span class="n">spmatrix</span><span class="p">,</span> <span class="n">coo_matrix</span><span class="p">,</span> <span class="n">csr_matrix</span>


<div class="viewcode-block" id="trajOptCollocProblem"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptCollocationProblem.trajOptCollocProblem">[docs]</a><span class="k">class</span> <span class="nc">trajOptCollocProblem</span><span class="p">(</span><span class="n">probFun</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A class for definition of trajectory optimization problem using collocation constraints.</span>

<span class="sd">    A general framework for using this class is to:</span>

<span class="sd">    1. Define a class which implements a DAE system, f(t, x, p, u)=0. This is a typical case for humanoid problem, but also flexible enough for simpler first order system.</span>
<span class="sd">    2. Optionally, write desired cost function by subclass/creating from the list of available cost functions. This can be built incrementally by adding pieces.</span>
<span class="sd">    3. Optionally, write desired constraint functions by subclass from available constraints. This can be built incrementally by adding pieces. Our approach can correctly detect the Jacobian structure.</span>
<span class="sd">    4. Create this class with selected system, discretization, t0, tf range</span>
<span class="sd">    5. Set bounds for state, control, parameters, x0 and xf</span>
<span class="sd">    6. Add objective functions and constraints to this class</span>
<span class="sd">    7. Call preProcess method explicitly</span>
<span class="sd">    8. Create snoptConfig instance and choose desired options</span>
<span class="sd">    9. Construct the solver</span>
<span class="sd">    10. Use the solver to solve with either automatic guess or user provided guess</span>

<span class="sd">    The system dynamics constraints are imposed using direct collocation approach with some additional optimization</span>
<span class="sd">    variables as suggested by others.</span>

<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="trajOptCollocProblem.__init__"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptCollocationProblem.trajOptCollocProblem.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sys</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">tf</span><span class="p">,</span> <span class="n">addx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize problem by system, discretization grid size, and allowable time</span>

<span class="sd">        Change history: now I remove gradmode option since I require the gradient be provided analytically all the time.</span>
<span class="sd">        I remove unnecessary linear objective functions.</span>
<span class="sd">        I reorder variable so q, dq, ddq, u, p are at consecutive place.</span>

<span class="sd">        :param sys: system, describe system dynamics</span>
<span class="sd">        :param N: int, discretization grid size, a uniform grid</span>
<span class="sd">        :param t0: float/array like, allowable t0</span>
<span class="sd">        :param tf: float/array like, allowable tf</span>
<span class="sd">        :param addX: list of addX / one addX / None, additional optimization variables.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sys</span><span class="p">,</span> <span class="n">daeSystem</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sys</span> <span class="o">=</span> <span class="n">sys</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="n">N</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nPoint</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">numT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handleTime</span><span class="p">(</span><span class="n">t0</span><span class="p">,</span> <span class="n">tf</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">nx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimdyn</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">nf</span>  <span class="c1"># dimension of dynamics constraint</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimu</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">nu</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimp</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">np</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimpoint</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">nx</span> <span class="o">+</span> <span class="n">sys</span><span class="o">.</span><span class="n">nu</span> <span class="o">+</span> <span class="n">sys</span><span class="o">.</span><span class="n">np</span>  <span class="c1"># each point have those variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">daeOrder</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">order</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">daeOrder</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dimq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimdyn</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">daeOrder</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dimq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimdyn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ubd</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xbd</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pbd</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x0bd</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xfbd</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="c1"># lqr cost function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lqrObj</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">LQRnG</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Linear cost function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linearObj</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># stores general linear cost</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linPointObj</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># stores linear cost imposed at a point</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linPathObj</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># stores Lagrange integral cost</span>
        <span class="c1"># nonlinear cost function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonLinObj</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># stores general nonlinear cost</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonPointObj</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># stores nonlinear cost imposed at a point</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonPathObj</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># stores Lagrange integral cost. Includes LQR cost</span>
        <span class="c1"># nonlinear constraints. Linear constraints are treated as nonlinear</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pointConstr</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># general constraint imposed at a certain point, such as initial and final point</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pathConstr</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># general constraint imposed everywhere such as collision avoidance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pathConstrIndexPairs</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># this records the indexes that path constraints are imposed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonLinConstr</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># stores general nonlinear constraint</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linPointConstr</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linPathConstr</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linearConstr</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># calculate number of variables to be optimized, time are always the last</span>
        <span class="n">numX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nPoint</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span>
        <span class="n">numU</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nPoint</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimu</span>
        <span class="n">numP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nPoint</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimp</span>
        <span class="k">if</span> <span class="n">addx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lenAddX</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">addx</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">addx</span> <span class="o">=</span> <span class="p">[</span><span class="n">addx</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">tmp</span> <span class="ow">in</span> <span class="n">addx</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">addX</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addX</span> <span class="o">=</span> <span class="n">addx</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lenAddX</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">tmp</span><span class="o">.</span><span class="n">n</span> <span class="k">for</span> <span class="n">tmp</span> <span class="ow">in</span> <span class="n">addx</span><span class="p">])</span>
        <span class="n">numSol</span> <span class="o">=</span> <span class="n">numX</span> <span class="o">+</span> <span class="n">numU</span> <span class="o">+</span> <span class="n">numP</span> <span class="o">+</span> <span class="n">numT</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numX</span> <span class="o">=</span> <span class="n">numX</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numU</span> <span class="o">=</span> <span class="n">numU</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numP</span> <span class="o">=</span> <span class="n">numP</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numT</span> <span class="o">=</span> <span class="n">numT</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numDynVar</span> <span class="o">=</span> <span class="n">numX</span> <span class="o">+</span> <span class="n">numU</span> <span class="o">+</span> <span class="n">numP</span>  <span class="c1"># numDynVar includes q, dq, ddq, u, p</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numTraj</span> <span class="o">=</span> <span class="n">numSol</span>  <span class="c1"># make it clear, numTraj contains numDynVar + time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numSol</span> <span class="o">=</span> <span class="n">numSol</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">lenAddX</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t0ind</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tfind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__getTimeIndices</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">colloc_constr_is_on</span> <span class="o">=</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="trajOptCollocProblem.pre_process"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptCollocationProblem.trajOptCollocProblem.pre_process">[docs]</a>    <span class="k">def</span> <span class="nf">pre_process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">colloc_constr_is_on</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">defect_u</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">defect_p</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the instances of probFun now we are ready.</span>

<span class="sd">        Call this function after the objectives and constraints have been set appropriately.</span>
<span class="sd">        It calculate the space required for SNOPT and allocates sparsity structure if necessary.</span>

<span class="sd">        :param colloc_constr_is_on: bool, if we also impose constraints on those collocation points.</span>
<span class="sd">        :param defect_u: bool, if we want to impose defect constraint on u, i.e. umid=(u0+uf)/2</span>
<span class="sd">        :param defect_p: bool, if we want to impose defect constraint on p, i.e. pmid=(p0+pf)/2</span>

<span class="sd">        **Caveat** it might make problem over-constrained, if the path constraints are equality constraints.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">defectU</span> <span class="o">=</span> <span class="n">defect_u</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">defectP</span> <span class="o">=</span> <span class="n">defect_p</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">colloc_constr_is_on</span> <span class="o">=</span> <span class="n">colloc_constr_is_on</span>
        <span class="n">numDyn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimdyn</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nPoint</span>  <span class="c1"># constraints from system dynamics, they are imposed everywhere</span>
        <span class="n">dynDefectSize</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">daeOrder</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimdyn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dynDefectSize</span> <span class="o">=</span> <span class="n">dynDefectSize</span>
        <span class="n">defectSize</span> <span class="o">=</span> <span class="n">dynDefectSize</span>
        <span class="k">if</span> <span class="n">defect_u</span><span class="p">:</span>
            <span class="n">defectSize</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimu</span>
        <span class="k">if</span> <span class="n">defect_p</span><span class="p">:</span>
            <span class="n">defectSize</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">defectSize</span> <span class="o">=</span> <span class="n">defectSize</span>
        <span class="n">numDefectDyn</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">defectSize</span>  <span class="c1"># from enforcing those guys</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numDefectDyn</span> <span class="o">=</span> <span class="n">numDefectDyn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numDyn</span> <span class="o">=</span> <span class="n">numDyn</span> <span class="o">+</span> <span class="n">numDefectDyn</span>  <span class="c1"># from both nonlinear dynamics and linear defect constraints</span>
        <span class="c1"># constrain t0 and tf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_t0_tf_constr</span><span class="p">()</span>

        <span class="n">numC</span><span class="p">,</span> <span class="n">nnonlincon</span><span class="p">,</span> <span class="n">nlincon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__sumConstrNum__</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">numLinCon</span> <span class="o">=</span> <span class="n">nlincon</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numNonLinCon</span> <span class="o">=</span> <span class="n">nnonlincon</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__findMaxNG__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numF</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">numDyn</span> <span class="o">+</span> <span class="n">numDefectDyn</span> <span class="o">+</span> <span class="n">numC</span>

        <span class="c1"># analyze all objective functions in order to detect pattern for A, and additional variables for other nonlinear objective function</span>
        <span class="n">spA</span><span class="p">,</span> <span class="n">addn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__analyzeObj__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numSol</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numF</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">objaddn</span> <span class="o">=</span> <span class="n">addn</span>  <span class="c1"># this is important for multiple objective function support</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numSol</span> <span class="o">+=</span> <span class="n">addn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numF</span> <span class="o">+=</span> <span class="n">addn</span>
        <span class="n">probFun</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numSol</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numF</span><span class="p">)</span>  <span class="c1"># not providing G means we use finite-difference</span>
        <span class="c1"># we are ready to write Aval, Arow, Acol for this problem. They are arranged right after dynamics</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__setAPattern__</span><span class="p">(</span><span class="n">numDyn</span><span class="p">,</span> <span class="n">nnonlincon</span><span class="p">,</span> <span class="n">spA</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__setXbound__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__setFbound__</span><span class="p">()</span>
        <span class="c1"># detect gradient information</span>
        <span class="n">randX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">randomGenX</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__turnOnGrad__</span><span class="p">(</span><span class="n">randX</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_handleTime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">tf</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Deal with time settings.</span>

<span class="sd">        If t0 and tf are both free, we want tf to be greater than t0</span>

<span class="sd">        :param t0: float/array like, allowable t0</span>
<span class="sd">        :param tf: float/array like, allowable tf</span>
<span class="sd">        :return: int, number of variable associated with time</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tf</span> <span class="o">=</span> <span class="n">tf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t0</span> <span class="o">=</span> <span class="n">t0</span>
        <span class="n">numT</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">tf</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fixtf</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">numT</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fixtf</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">assert</span> <span class="n">tf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">tf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">t0</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fixt0</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">numT</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fixt0</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">assert</span> <span class="n">t0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">t0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixt0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixtf</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fixTimeMode</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fixTimeMode</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">numT</span>

    <span class="k">def</span> <span class="nf">_set_t0_tf_constr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Based on occasions, we set constraints on time.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixt0</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixtf</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0</span> <span class="o">+</span> <span class="mf">1e-6</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixtf</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">t0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t0</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">tf</span> <span class="o">-</span> <span class="mf">1e-6</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tf</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>  <span class="c1"># we might have trouble</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numSol</span><span class="p">))</span>
                    <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0ind</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tfind</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">addConstr</span><span class="p">(</span><span class="n">linearConstr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">-</span><span class="mf">1e20</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="mf">1e-6</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">__sumConstrNum__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;It simply calculate constraint numbers.&quot;&quot;&quot;</span>
        <span class="n">numC</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">constr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointConstr</span><span class="p">:</span>
            <span class="n">numC</span> <span class="o">+=</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span>
        <span class="k">for</span> <span class="n">constr</span><span class="p">,</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pathConstr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pathConstrIndexPairs</span><span class="p">):</span>
            <span class="n">tmpN</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">colloc_constr_is_on</span><span class="p">:</span>
                <span class="n">numC</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">tmpN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">numC</span> <span class="o">+=</span> <span class="n">tmpN</span> <span class="o">*</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span>
        <span class="k">for</span> <span class="n">constr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonLinConstr</span><span class="p">:</span>
            <span class="n">numC</span> <span class="o">+=</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span>
        <span class="n">nnonlincon</span> <span class="o">=</span> <span class="n">numC</span>
        <span class="k">for</span> <span class="n">constr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">linPointConstr</span><span class="p">:</span>
            <span class="n">numC</span> <span class="o">+=</span> <span class="n">constr</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">constr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">linPathConstr</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">colloc_constr_is_on</span><span class="p">:</span>
                <span class="n">numC</span> <span class="o">+=</span> <span class="n">constr</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nPoint</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">numC</span> <span class="o">+=</span> <span class="n">constr</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span>
        <span class="k">for</span> <span class="n">constr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">linearConstr</span><span class="p">:</span>
            <span class="n">numC</span> <span class="o">+=</span> <span class="n">constr</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">nlincon</span> <span class="o">=</span> <span class="n">numC</span> <span class="o">-</span> <span class="n">nnonlincon</span>
        <span class="k">return</span> <span class="n">numC</span><span class="p">,</span> <span class="n">nnonlincon</span><span class="p">,</span> <span class="n">nlincon</span>

<div class="viewcode-block" id="trajOptCollocProblem.genGuessFromTraj"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptCollocationProblem.trajOptCollocProblem.genGuessFromTraj">[docs]</a>    <span class="k">def</span> <span class="nf">genGuessFromTraj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">U</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">P</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">t0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">addx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tstamp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">obj</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">interp_kind</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate an initial guess for the problem with user specified information.</span>

<span class="sd">        An amazing feature is the user does not have to give a solution of exactly the same time-stamped trajectory used internally.</span>
<span class="sd">        Interpolation approaches are used in such scenarios.</span>
<span class="sd">        The user is not required to provide them all, although we suggest they do so.</span>

<span class="sd">        :param X: ndarray, (x, x) each row corresponds to a state snapshot (if tstamp is None, assume equidistant grid). Column size can be dimx or dimx/sys.order</span>
<span class="sd">        :param U: ndarray, (x, dimu) each row corresponds to a control snapshot. Similar to X but with column size equals dimu</span>
<span class="sd">        :param P: ndarray, (x, dimp) each row corresponds to a parameter snapshot. Similar to X but with column size equals dimp</span>
<span class="sd">        :param t0/tf: float/array-like, initial/final time. If None, we randomly generate one</span>
<span class="sd">        :param addx: list of ndarray, guess of addx, if applicable</span>
<span class="sd">        :param tstamp: ndarray, (x,), None if the X/U/P are provided using equidistant grid.</span>
<span class="sd">        :param obj: ndarray, (x,) the objective part</span>
<span class="sd">        :param interp_kind: str, interpolation type for scipy.interpolate.interp1d, can be (âlinearâ, ânearestâ, âzeroâ, âslinearâ, âquadraticâ, âcubicâ)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">randX</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numSol</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">Xtarget</span><span class="p">,</span> <span class="n">Utarget</span><span class="p">,</span> <span class="n">Ptarget</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parseX__</span><span class="p">(</span><span class="n">randX</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">obj_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parseObj__</span><span class="p">(</span><span class="n">randX</span><span class="p">)</span>
            <span class="n">obj_</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">obj</span>
        <span class="c1"># generate t0 and tf, if applicable</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0ind</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">t0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">randX</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">t0ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">randomGenInBound</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">randX</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">t0ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">randomGenInBound</span><span class="p">(</span><span class="n">t0</span><span class="p">)</span>
            <span class="n">uset0</span> <span class="o">=</span> <span class="n">randX</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">t0ind</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">uset0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tfind</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">randX</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tfind</span><span class="p">]</span> <span class="o">=</span> <span class="n">randomGenInBound</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tf</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">randX</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tfind</span><span class="p">]</span> <span class="o">=</span> <span class="n">randomGenInBound</span><span class="p">(</span><span class="n">tf</span><span class="p">)</span>
            <span class="n">usetf</span> <span class="o">=</span> <span class="n">randX</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tfind</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">usetf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tf</span>
        <span class="n">teval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">uset0</span><span class="p">,</span> <span class="n">usetf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nPoint</span><span class="p">)</span>

        <span class="c1"># interpolation for state variables</span>
        <span class="n">nPoint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nPoint</span>
        <span class="n">dimx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span>
        <span class="n">dimx_</span> <span class="o">=</span> <span class="n">dimx</span> <span class="o">//</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sys</span><span class="o">.</span><span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">X</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Xcol</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">Xcol</span> <span class="o">==</span> <span class="n">dimx_</span> <span class="ow">or</span> <span class="n">Xcol</span> <span class="o">==</span> <span class="n">dimx</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The column of X is not </span><span class="si">%d</span><span class="s1"> or </span><span class="si">%d</span><span class="s1">, not use it&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dimx</span><span class="p">,</span> <span class="n">dimx_</span><span class="p">))</span>
                <span class="n">X</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># use interpolation to do it</span>
                <span class="n">interp</span><span class="p">(</span><span class="n">tstamp</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">teval</span><span class="p">,</span> <span class="n">Xtarget</span><span class="p">,</span> <span class="n">interp_kind</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">X</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># straight path go there</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nPoint</span><span class="p">):</span>
                <span class="n">Xtarget</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">randomGenInBound</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xbd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span><span class="p">)</span>
            <span class="c1"># randomly generate x0 and xf</span>
            <span class="n">Xtarget</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:</span><span class="n">dimx</span><span class="p">]</span> <span class="o">=</span> <span class="n">randomGenInBound</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x0bd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span><span class="p">)</span>
            <span class="n">Xtarget</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="n">dimx</span><span class="p">]</span> <span class="o">=</span> <span class="n">randomGenInBound</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xfbd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span><span class="p">)</span>

        <span class="c1"># interpolation for control variable</span>
        <span class="k">if</span> <span class="n">U</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">interp</span><span class="p">(</span><span class="n">tstamp</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">teval</span><span class="p">,</span> <span class="n">Utarget</span><span class="p">,</span> <span class="n">interp_kind</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nPoint</span><span class="p">):</span>
                <span class="n">Utarget</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">randomGenInBound</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ubd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimu</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">numP</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">P</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">interp</span><span class="p">(</span><span class="n">tstamp</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">teval</span><span class="p">,</span> <span class="n">Ptarget</span><span class="p">,</span> <span class="n">interp_kind</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nPoint</span><span class="p">):</span>
                    <span class="n">Ptarget</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">randomGenInBound</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pbd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimp</span><span class="p">)</span>
        <span class="c1"># generate for</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lenAddX</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">addx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="n">addx_</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__parseAddX__</span><span class="p">(</span><span class="n">randX</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">addX</span><span class="p">):</span>
                    <span class="n">field</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">randomGenInBound</span><span class="p">([</span><span class="n">addx_</span><span class="o">.</span><span class="n">lb</span><span class="p">,</span> <span class="n">addx_</span><span class="o">.</span><span class="n">ub</span><span class="p">],</span> <span class="n">addx_</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">guess</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">addx_</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">addx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parseAddX__</span><span class="p">(</span><span class="n">randX</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">addX</span><span class="p">):</span>
                    <span class="n">field</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">randomGenInBound</span><span class="p">(</span><span class="n">guess</span><span class="p">,</span> <span class="n">addx_</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
        <span class="c1"># I do not have to worry about objaddn since they are linear</span>
        <span class="k">return</span> <span class="n">randX</span></div>

<div class="viewcode-block" id="trajOptCollocProblem.genGuessFromSol"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptCollocationProblem.trajOptCollocProblem.genGuessFromSol">[docs]</a>    <span class="k">def</span> <span class="nf">genGuessFromSol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parsed_sol</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate an initial guess from a previous solution. Mainly change grid size or add perturbation. But determining structure is difficult</span>

<span class="sd">        :param parsed_sol: dictionary, output of calling parseSol</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">parsed_sol</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">parsed_sol</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">parsed_sol</span><span class="p">[</span><span class="s1">&#39;u&#39;</span><span class="p">]</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">parsed_sol</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">addx</span> <span class="o">=</span> <span class="n">parsed_sol</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;addx&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">parsed_sol</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;obj&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">genGuessFromTraj</span><span class="p">(</span><span class="n">X</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">U</span><span class="o">=</span><span class="n">u</span><span class="p">,</span> <span class="n">P</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">t0</span><span class="o">=</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tf</span><span class="o">=</span><span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">addx</span><span class="o">=</span><span class="n">addx</span><span class="p">,</span> <span class="n">tstamp</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">obj</span><span class="o">=</span><span class="n">obj</span><span class="p">,</span> <span class="n">interp_kind</span><span class="o">=</span><span class="s1">&#39;cubic&#39;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__findMaxNG__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Loop over all the constraints, find max NG. We then create temporary data for them.&quot;&quot;&quot;</span>
        <span class="n">maxnG</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">maxnG</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxnG</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sys</span><span class="o">.</span><span class="n">nG</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">constr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointConstr</span><span class="p">:</span>
            <span class="n">maxnG</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxnG</span><span class="p">,</span> <span class="n">constr</span><span class="o">.</span><span class="n">nG</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">constr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pathConstr</span><span class="p">:</span>
            <span class="n">maxnG</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxnG</span><span class="p">,</span> <span class="n">constr</span><span class="o">.</span><span class="n">nG</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">constr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonLinConstr</span><span class="p">:</span>
            <span class="n">maxnG</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxnG</span><span class="p">,</span> <span class="n">constr</span><span class="o">.</span><span class="n">nG</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">maxnG</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">maxnG</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">maxnG</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__analyzeObj__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">numSol</span><span class="p">,</span> <span class="n">numF</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Analyze the objective function.</span>

<span class="sd">        :param numSol: current estimation of free variables</span>
<span class="sd">        :param numF: current estimation of rows of constraints</span>
<span class="sd">        :return spA: coo sparse matrix, records first row of A, and last rows of A</span>
<span class="sd">        :return addn: int, additional nonlinear constraint. As long as nonlinear obj exists, this is non-zero</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># detect how many nonlinear objective functions we have</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lqrObj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nnlin</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nnlin</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">nnlin</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonLinObj</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonPathObj</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonPointObj</span><span class="p">)</span>
        <span class="n">addn</span> <span class="o">=</span> <span class="n">nnlin</span>
        <span class="c1"># analyze the linear objective functions in a good way</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">numSol</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">linearObj</span><span class="p">:</span>
            <span class="n">A</span><span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">col</span><span class="p">]</span> <span class="o">+=</span> <span class="n">obj</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">data</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">linPointObj</span><span class="p">:</span>
            <span class="n">A</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">__patchCol__</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">col</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">obj</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">data</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">linPathObj</span><span class="p">:</span>  <span class="c1"># this is not particularly useful, I have to say</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nPoint</span><span class="p">):</span>
                <span class="n">A</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">__patchCol__</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">col</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">obj</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">data</span>
        <span class="c1"># get sparse representation of A</span>
        <span class="n">nnzind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">A</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">A_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">addn</span><span class="p">)</span>
        <span class="n">row_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">addn</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">col_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">addn</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="c1"># for the addn</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">addn</span><span class="p">):</span>
            <span class="n">A_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">A_</span><span class="p">[</span><span class="n">addn</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">col_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">numSol</span> <span class="o">+</span> <span class="n">i</span>
            <span class="n">col_</span><span class="p">[</span><span class="n">addn</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">numSol</span> <span class="o">+</span> <span class="n">i</span>
            <span class="n">row_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">row_</span><span class="p">[</span><span class="n">addn</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">numF</span> <span class="o">+</span> <span class="n">i</span>
        <span class="c1"># concat them</span>
        <span class="n">catA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">A</span><span class="p">[</span><span class="n">nnzind</span><span class="p">],</span> <span class="n">A_</span><span class="p">))</span>
        <span class="n">catArow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nnzind</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> <span class="n">row_</span><span class="p">))</span>
        <span class="n">catAcol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">nnzind</span><span class="p">,</span> <span class="n">col_</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">catA</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">spA</span> <span class="o">=</span> <span class="n">coo_matrix</span><span class="p">(([],</span> <span class="p">([],</span> <span class="p">[])),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">addn</span> <span class="o">+</span> <span class="n">numF</span><span class="p">,</span> <span class="n">numSol</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">spA</span> <span class="o">=</span> <span class="n">coo_matrix</span><span class="p">((</span><span class="n">catA</span><span class="p">,</span> <span class="p">(</span><span class="n">catArow</span><span class="p">,</span> <span class="n">catAcol</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">spA</span><span class="p">,</span> <span class="n">addn</span>

    <span class="k">def</span> <span class="nf">__setAPattern__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ndyncon</span><span class="p">,</span> <span class="n">nnonlincon</span><span class="p">,</span> <span class="n">spA</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set sparsity pattern from linear constraints and objective functions.</span>

<span class="sd">        It finds sparsity pattern from defect constraints, linear constraints, and objective functions.</span>
<span class="sd">        It also finds sparsity pattern from those linear constraints.</span>
<span class="sd">        The A matrix from objective function is given in the sparse A and we just append it.</span>
<span class="sd">        The rows from linear constraints are straightforward.</span>
<span class="sd">        The constraints from defect constraints lie from rows 1 + ndyncon and occupies defectSize rows</span>
<span class="sd">        After nnonlincon rows (empty in A), we set linear constraints.</span>

<span class="sd">        The size of defect A: dynDefectSize = 2 * daeOrder * dimdyn and defectSize = dynDefectSize + dimu + dimp</span>
<span class="sd">        It sums up to 3*(dimu + dimp) + daeOrder*5*2*dimdyn nnz</span>
<span class="sd">        We have to do this for self.N - 1 mid-points.</span>

<span class="sd">        :param ndyncon: int, describes how many dynamics constraints we have</span>
<span class="sd">        :param nnonlincon: int, describes how many nonlinear constraints we have</span>
<span class="sd">        :param spA: sparse matrix, how the objective function is described linearly.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">curRow</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__setDefectPattern__</span><span class="p">(</span><span class="n">ndyncon</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">defectU</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">defectP</span><span class="p">)</span>
        <span class="n">curRow</span> <span class="o">+=</span> <span class="n">nnonlincon</span>
        <span class="c1"># we are ready to parse linear constraints</span>
        <span class="n">lstCA</span><span class="p">,</span> <span class="n">lstCArow</span><span class="p">,</span> <span class="n">lstCAcol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parseLinearConstraints__</span><span class="p">(</span><span class="n">curRow</span><span class="p">)</span>
        <span class="c1"># concatenate all those things together</span>
        <span class="n">lstCA</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spA</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="n">lstCA</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="n">lstCArow</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spA</span><span class="o">.</span><span class="n">row</span><span class="p">)</span>
        <span class="n">lstCArow</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
        <span class="n">lstCAcol</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spA</span><span class="o">.</span><span class="n">col</span><span class="p">)</span>
        <span class="n">lstCAcol</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
        <span class="n">Aval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">lstCA</span><span class="p">)</span>
        <span class="n">Arow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">lstCArow</span><span class="p">)</span>
        <span class="n">Acol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">lstCAcol</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_a_by_triplet</span><span class="p">(</span><span class="n">Aval</span><span class="p">,</span> <span class="n">Arow</span><span class="p">,</span> <span class="n">Acol</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spA</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Aval</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Arow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Acol</span><span class="p">)),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spA_coo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spA</span><span class="o">.</span><span class="n">tocoo</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__setDefectPattern__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ndyncon</span><span class="p">,</span> <span class="n">withu</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">withp</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the sparse linear constraints from defect constraints.</span>

<span class="sd">        :param ndyncon: number of dynamical constraints. This sets starting row.</span>
<span class="sd">        :param withu: bool, determines if we set defect constraint on u</span>
<span class="sd">        :param withp: bool, determines if we set defect constraint on p</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dimx</span><span class="p">,</span> <span class="n">dimu</span><span class="p">,</span> <span class="n">dimp</span><span class="p">,</span> <span class="n">dimpoint</span><span class="p">,</span> <span class="n">dimdyn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimpoint</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimdyn</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">withp</span><span class="p">:</span>
            <span class="n">dimp</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">withu</span><span class="p">:</span>
            <span class="n">dimu</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixTimeMode</span><span class="p">:</span>
            <span class="n">lenA</span> <span class="o">=</span> <span class="p">(</span><span class="mi">10</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">daeOrder</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dimdyn</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">dimu</span> <span class="o">+</span> <span class="n">dimp</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lenA</span> <span class="o">=</span> <span class="p">(</span><span class="mi">6</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">daeOrder</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dimdyn</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">dimu</span> <span class="o">+</span> <span class="n">dimp</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">lenA</span><span class="p">)</span>
        <span class="n">row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">lenA</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">lenA</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">curNA</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">curRow</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">ndyncon</span>
        <span class="c1"># find those three matrix</span>
        <span class="n">spL</span><span class="p">,</span> <span class="n">spM</span><span class="p">,</span> <span class="n">spR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__findMatLMRTemplate</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">midi</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">lefti</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">i</span>
            <span class="n">righti</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">daeOrder</span><span class="p">):</span>
                <span class="n">A</span><span class="p">[</span><span class="n">curNA</span><span class="p">:</span> <span class="n">curNA</span> <span class="o">+</span> <span class="n">spL</span><span class="o">.</span><span class="n">nnz</span><span class="p">]</span> <span class="o">=</span> <span class="n">spL</span><span class="o">.</span><span class="n">data</span>
                <span class="n">row</span><span class="p">[</span><span class="n">curNA</span><span class="p">:</span> <span class="n">curNA</span> <span class="o">+</span> <span class="n">spL</span><span class="o">.</span><span class="n">nnz</span><span class="p">]</span> <span class="o">=</span> <span class="n">spL</span><span class="o">.</span><span class="n">row</span> <span class="o">+</span> <span class="n">curRow</span>
                <span class="n">col</span><span class="p">[</span><span class="n">curNA</span><span class="p">:</span> <span class="n">curNA</span> <span class="o">+</span> <span class="n">spL</span><span class="o">.</span><span class="n">nnz</span><span class="p">]</span> <span class="o">=</span> <span class="n">spL</span><span class="o">.</span><span class="n">col</span> <span class="o">+</span> <span class="n">lefti</span> <span class="o">*</span> <span class="n">dimpoint</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">dimdyn</span>
                <span class="n">curNA</span> <span class="o">+=</span> <span class="n">spL</span><span class="o">.</span><span class="n">nnz</span>
                <span class="n">A</span><span class="p">[</span><span class="n">curNA</span><span class="p">:</span> <span class="n">curNA</span> <span class="o">+</span> <span class="n">spM</span><span class="o">.</span><span class="n">nnz</span><span class="p">]</span> <span class="o">=</span> <span class="n">spM</span><span class="o">.</span><span class="n">data</span>
                <span class="n">row</span><span class="p">[</span><span class="n">curNA</span><span class="p">:</span> <span class="n">curNA</span> <span class="o">+</span> <span class="n">spM</span><span class="o">.</span><span class="n">nnz</span><span class="p">]</span> <span class="o">=</span> <span class="n">spM</span><span class="o">.</span><span class="n">row</span> <span class="o">+</span> <span class="n">curRow</span>
                <span class="n">col</span><span class="p">[</span><span class="n">curNA</span><span class="p">:</span> <span class="n">curNA</span> <span class="o">+</span> <span class="n">spM</span><span class="o">.</span><span class="n">nnz</span><span class="p">]</span> <span class="o">=</span> <span class="n">spM</span><span class="o">.</span><span class="n">col</span> <span class="o">+</span> <span class="n">midi</span> <span class="o">*</span> <span class="n">dimpoint</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">dimdyn</span>
                <span class="n">curNA</span> <span class="o">+=</span> <span class="n">spM</span><span class="o">.</span><span class="n">nnz</span>
                <span class="n">A</span><span class="p">[</span><span class="n">curNA</span><span class="p">:</span> <span class="n">curNA</span> <span class="o">+</span> <span class="n">spR</span><span class="o">.</span><span class="n">nnz</span><span class="p">]</span> <span class="o">=</span> <span class="n">spR</span><span class="o">.</span><span class="n">data</span>
                <span class="n">row</span><span class="p">[</span><span class="n">curNA</span><span class="p">:</span> <span class="n">curNA</span> <span class="o">+</span> <span class="n">spR</span><span class="o">.</span><span class="n">nnz</span><span class="p">]</span> <span class="o">=</span> <span class="n">spR</span><span class="o">.</span><span class="n">row</span> <span class="o">+</span> <span class="n">curRow</span>
                <span class="n">col</span><span class="p">[</span><span class="n">curNA</span><span class="p">:</span> <span class="n">curNA</span> <span class="o">+</span> <span class="n">spR</span><span class="o">.</span><span class="n">nnz</span><span class="p">]</span> <span class="o">=</span> <span class="n">spR</span><span class="o">.</span><span class="n">col</span> <span class="o">+</span> <span class="n">righti</span> <span class="o">*</span> <span class="n">dimpoint</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">dimdyn</span>
                <span class="n">curNA</span> <span class="o">+=</span> <span class="n">spR</span><span class="o">.</span><span class="n">nnz</span>
                <span class="n">curRow</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">dimdyn</span>  <span class="c1"># since size of spL, it is 2d by 2d</span>
        <span class="c1"># then do the constraint of u and p on nodes and knots, basically, midpoint is the average of two knots</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">midi</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">lefti</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">i</span>
            <span class="n">righti</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">A</span><span class="p">[</span><span class="n">curNA</span><span class="p">:</span> <span class="n">curNA</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">dimu</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span>
            <span class="n">A</span><span class="p">[</span><span class="n">curNA</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">dimu</span><span class="p">:</span> <span class="n">curNA</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">dimu</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">A</span><span class="p">[</span><span class="n">curNA</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">dimu</span><span class="p">:</span> <span class="n">curNA</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">dimu</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">dimp</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span>
            <span class="n">A</span><span class="p">[</span><span class="n">curNA</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">dimu</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">dimp</span><span class="p">:</span> <span class="n">curNA</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">dimu</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">dimp</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">row</span><span class="p">[</span><span class="n">curNA</span><span class="p">:</span> <span class="n">curNA</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">dimu</span><span class="p">]</span> <span class="o">=</span> <span class="n">curRow</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dimu</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="n">col</span><span class="p">[</span><span class="n">curNA</span><span class="p">:</span> <span class="n">curNA</span> <span class="o">+</span> <span class="n">dimu</span><span class="p">]</span> <span class="o">=</span> <span class="n">lefti</span> <span class="o">*</span> <span class="n">dimpoint</span> <span class="o">+</span> <span class="n">dimx</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dimu</span><span class="p">)</span>
            <span class="n">col</span><span class="p">[</span><span class="n">curNA</span> <span class="o">+</span> <span class="n">dimu</span><span class="p">:</span> <span class="n">curNA</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">dimu</span><span class="p">]</span> <span class="o">=</span> <span class="n">righti</span> <span class="o">*</span> <span class="n">dimpoint</span> <span class="o">+</span> <span class="n">dimx</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dimu</span><span class="p">)</span>
            <span class="n">col</span><span class="p">[</span><span class="n">curNA</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">dimu</span><span class="p">:</span> <span class="n">curNA</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">dimu</span><span class="p">]</span> <span class="o">=</span> <span class="n">midi</span> <span class="o">*</span> <span class="n">dimpoint</span> <span class="o">+</span> <span class="n">dimx</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dimu</span><span class="p">)</span>
            <span class="n">curNA_</span> <span class="o">=</span> <span class="n">curNA</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">dimu</span>
            <span class="n">row</span><span class="p">[</span><span class="n">curNA_</span><span class="p">:</span> <span class="n">curNA_</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">dimp</span><span class="p">]</span> <span class="o">=</span> <span class="n">curRow</span> <span class="o">+</span> <span class="n">dimu</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dimp</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="n">col</span><span class="p">[</span><span class="n">curNA_</span><span class="p">:</span> <span class="n">curNA_</span> <span class="o">+</span> <span class="n">dimp</span><span class="p">]</span> <span class="o">=</span> <span class="n">lefti</span> <span class="o">*</span> <span class="n">dimpoint</span> <span class="o">+</span> <span class="n">dimx</span> <span class="o">+</span> <span class="n">dimu</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dimp</span><span class="p">)</span>
            <span class="n">col</span><span class="p">[</span><span class="n">curNA_</span> <span class="o">+</span> <span class="n">dimp</span><span class="p">:</span> <span class="n">curNA_</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">dimp</span><span class="p">]</span> <span class="o">=</span> <span class="n">righti</span> <span class="o">*</span> <span class="n">dimpoint</span> <span class="o">+</span> <span class="n">dimx</span> <span class="o">+</span> <span class="n">dimu</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dimp</span><span class="p">)</span>
            <span class="n">col</span><span class="p">[</span><span class="n">curNA_</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">dimp</span><span class="p">:</span> <span class="n">curNA_</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">dimp</span><span class="p">]</span> <span class="o">=</span> <span class="n">midi</span> <span class="o">*</span> <span class="n">dimpoint</span> <span class="o">+</span> <span class="n">dimx</span> <span class="o">+</span> <span class="n">dimu</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dimp</span><span class="p">)</span>
            <span class="n">curNA</span> <span class="o">+=</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="n">dimu</span> <span class="o">+</span> <span class="n">dimp</span><span class="p">)</span>
            <span class="n">curRow</span> <span class="o">+=</span> <span class="n">dimu</span> <span class="o">+</span> <span class="n">dimp</span>
        <span class="k">return</span> <span class="n">curRow</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span>

    <span class="k">def</span> <span class="nf">__parseLinearConstraints__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">curRow</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Parse the linear constraints and form a sparse matrix.</span>

<span class="sd">        :param curRow: current row of accumulated constraints.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lstCA</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">lstCArow</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">lstCAcol</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">constr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">linPointConstr</span><span class="p">:</span>  <span class="c1"># TODO: support for time to be done</span>
            <span class="n">lstCA</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">constr</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="n">lstCArow</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">constr</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">row</span> <span class="o">+</span> <span class="n">curRow</span><span class="p">)</span>
            <span class="n">lstCAcol</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__patchCol__</span><span class="p">(</span><span class="n">constr</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">constr</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">col</span><span class="p">))</span>  <span class="c1"># take care on here</span>
            <span class="n">curRow</span> <span class="o">+=</span> <span class="n">constr</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">constr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">linPathConstr</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nPoint</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">colloc_constr_is_on</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">j</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">continue</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">j</span>
                <span class="n">lstCA</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">constr</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
                <span class="n">lstCArow</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">constr</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">row</span> <span class="o">+</span> <span class="n">curRow</span><span class="p">)</span>
                <span class="n">lstCAcol</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__patchCol__</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">constr</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">col</span><span class="p">))</span>
                <span class="n">curRow</span> <span class="o">+=</span> <span class="n">constr</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">constr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">linearConstr</span><span class="p">:</span>
            <span class="c1"># the users have to be aware of the columns</span>
            <span class="n">lstCA</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">constr</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="n">lstCArow</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">constr</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">row</span> <span class="o">+</span> <span class="n">curRow</span><span class="p">)</span>
            <span class="n">lstCAcol</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">constr</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">col</span><span class="p">)</span>
            <span class="n">curRow</span> <span class="o">+=</span> <span class="n">constr</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">lstCA</span><span class="p">,</span> <span class="n">lstCArow</span><span class="p">,</span> <span class="n">lstCAcol</span>

    <span class="k">def</span> <span class="nf">__findMatLMRTemplate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Assume h is fixed, we find the L, M, R matrix for defect constraints.</span>

<span class="sd">        The goal is for a pair (q^(k), q^{(k+1)}) we want MatL*L+MatM*M+MatR*R=0</span>
<span class="sd">        where L, M, R are such pair at left point, mid-point, and right point.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimdyn</span>
        <span class="n">matL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">d</span><span class="p">))</span>
        <span class="n">matM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">d</span><span class="p">))</span>
        <span class="n">matR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">d</span><span class="p">))</span>
        <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">matL</span><span class="p">[:</span><span class="n">d</span><span class="p">,</span> <span class="p">:</span><span class="n">d</span><span class="p">],</span> <span class="mf">0.5</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">matL</span><span class="p">[</span><span class="n">d</span><span class="p">:,</span> <span class="n">d</span><span class="p">:],</span> <span class="o">-</span><span class="mf">0.25</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">matM</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">matR</span><span class="p">[:</span><span class="n">d</span><span class="p">,</span> <span class="p">:</span><span class="n">d</span><span class="p">],</span> <span class="mf">0.5</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">matR</span><span class="p">[</span><span class="n">d</span><span class="p">:,</span> <span class="n">d</span><span class="p">:],</span> <span class="o">-</span><span class="mf">0.25</span><span class="p">)</span>
        <span class="c1"># time dependent parts</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixTimeMode</span><span class="p">:</span>
            <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tf</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">matL</span><span class="p">[:</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">:],</span> <span class="n">h</span><span class="o">/</span><span class="mi">8</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">matL</span><span class="p">[</span><span class="n">d</span><span class="p">:,</span> <span class="p">:</span><span class="n">d</span><span class="p">],</span> <span class="o">-</span><span class="mf">1.5</span><span class="o">/</span><span class="n">h</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">matR</span><span class="p">[:</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">:],</span> <span class="o">-</span><span class="n">h</span><span class="o">/</span><span class="mi">8</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">matR</span><span class="p">[</span><span class="n">d</span><span class="p">:,</span> <span class="p">:</span><span class="n">d</span><span class="p">],</span> <span class="mf">1.5</span><span class="o">/</span><span class="n">h</span><span class="p">)</span>
        <span class="n">spL</span> <span class="o">=</span> <span class="n">coo_matrix</span><span class="p">(</span><span class="n">matL</span><span class="p">)</span>
        <span class="n">spM</span> <span class="o">=</span> <span class="n">coo_matrix</span><span class="p">(</span><span class="n">matM</span><span class="p">)</span>
        <span class="n">spR</span> <span class="o">=</span> <span class="n">coo_matrix</span><span class="p">(</span><span class="n">matR</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">spL</span><span class="p">,</span> <span class="n">spM</span><span class="p">,</span> <span class="n">spR</span>

<div class="viewcode-block" id="trajOptCollocProblem.randomGenX"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptCollocationProblem.trajOptCollocProblem.randomGenX">[docs]</a>    <span class="k">def</span> <span class="nf">randomGenX</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A more reansonable approach to generate random guess for the problem.</span>

<span class="sd">        It considers bounds on initial and final states so this is satisfied.</span>
<span class="sd">        Then it linearly interpolate between states.</span>
<span class="sd">        Controls are randomly generated within control bound, if it presents. Otherwise [-1, 1]</span>

<span class="sd">        :return x: ndarray, (numSol, ) an initial guess of the solution</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nPoint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nPoint</span>
        <span class="n">dimx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span>
        <span class="n">randX</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numSol</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parseX__</span><span class="p">(</span><span class="n">randX</span><span class="p">)</span>
        <span class="c1"># randomly generate x0 and xf</span>
        <span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:</span><span class="n">dimx</span><span class="p">]</span> <span class="o">=</span> <span class="n">randomGenInBound</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x0bd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span><span class="p">)</span>
        <span class="n">X</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="n">dimx</span><span class="p">]</span> <span class="o">=</span> <span class="n">randomGenInBound</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xfbd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span><span class="p">)</span>
        <span class="c1"># straight path go there</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimx</span><span class="p">):</span>
            <span class="n">X</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="n">nPoint</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nPoint</span><span class="p">):</span>
            <span class="n">U</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">randomGenInBound</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ubd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimu</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">numP</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nPoint</span><span class="p">):</span>
                <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">randomGenInBound</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pbd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimp</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0ind</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">randX</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">t0ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">randomGenInBound</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t0</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tfind</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">randX</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tfind</span><span class="p">]</span> <span class="o">=</span> <span class="n">randomGenInBound</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tf</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lenAddX</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="n">addx</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__parseAddX__</span><span class="p">(</span><span class="n">randX</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">addX</span><span class="p">):</span>
                <span class="n">field</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">randomGenInBound</span><span class="p">([</span><span class="n">addx</span><span class="o">.</span><span class="n">lb</span><span class="p">,</span> <span class="n">addx</span><span class="o">.</span><span class="n">ub</span><span class="p">],</span> <span class="n">addx</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
        <span class="c1"># I do not have to worry about objaddn since they are linear</span>
        <span class="k">return</span> <span class="n">randX</span></div>

    <span class="k">def</span> <span class="nf">__turnOnGrad__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Turn on gradient, this is called after an initial x0 has been generated&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grad</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__getSparsity__</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getSparsity__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Detect sparsity of the problem with an initial guess.&quot;&quot;&quot;</span>
        <span class="n">numObjG</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__getObjSparsity</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numObjG</span> <span class="o">=</span> <span class="n">numObjG</span>
        <span class="c1"># summarize number of pure linear constraints</span>
        <span class="n">numDynG</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__getDynSparsity</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
        <span class="n">numCG</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># G from C</span>

        <span class="n">h</span><span class="p">,</span> <span class="n">useT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_time_grid__</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
        <span class="n">useX</span><span class="p">,</span> <span class="n">useU</span><span class="p">,</span> <span class="n">useP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parseX__</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nPoint</span><span class="p">)</span>
        <span class="n">tmpx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="n">useT</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">useX</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">useU</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">useP</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

        <span class="k">for</span> <span class="n">constr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointConstr</span><span class="p">:</span>
            <span class="n">numCG</span> <span class="o">+=</span> <span class="n">constr</span><span class="o">.</span><span class="n">nG</span>
            <span class="n">constr</span><span class="o">.</span><span class="n">findTimeGradient</span><span class="p">(</span><span class="n">tmpx</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">constr</span><span class="o">.</span><span class="n">autonomous</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">constr</span><span class="o">.</span><span class="n">timeindex</span><span class="p">)</span>
                <span class="n">numCG</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">n</span>
        <span class="k">for</span> <span class="n">constr</span><span class="p">,</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pathConstr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pathConstrIndexPairs</span><span class="p">):</span>
            <span class="n">tmpN</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">colloc_constr_is_on</span><span class="p">:</span>
                <span class="n">numCG</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">tmpN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">constr</span><span class="o">.</span><span class="n">nG</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">numCG</span> <span class="o">+=</span> <span class="n">tmpN</span> <span class="o">*</span> <span class="n">constr</span><span class="o">.</span><span class="n">nG</span>
            <span class="n">constr</span><span class="o">.</span><span class="n">findTimeGradient</span><span class="p">(</span><span class="n">tmpx</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">constr</span><span class="o">.</span><span class="n">autonomous</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">constr</span><span class="o">.</span><span class="n">timeindex</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">colloc_constr_is_on</span><span class="p">:</span>
                    <span class="n">numCG</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">n</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nPoint</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">numCG</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">n</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span>
        <span class="k">for</span> <span class="n">constr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonLinConstr</span><span class="p">:</span>
            <span class="n">numCG</span> <span class="o">+=</span> <span class="n">constr</span><span class="o">.</span><span class="n">nG</span>
        <span class="n">numG</span> <span class="o">=</span> <span class="n">numObjG</span> <span class="o">+</span> <span class="n">numDynG</span> <span class="o">+</span> <span class="n">numCG</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numG</span> <span class="o">=</span> <span class="n">numG</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nG</span> <span class="o">=</span> <span class="n">numG</span>

    <span class="k">def</span> <span class="nf">__getDynSparsity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set sparsity of the problem caused by system dynamics and other nonlinear constraints.</span>

<span class="sd">        Sparsity pattern should be quite straight-forward to conclude since we introduce many auxiliary variables.</span>
<span class="sd">        The nG from dae system should be directly used and it is complete.</span>
<span class="sd">        The defect constraints introduce 5*dimq*4 gradients</span>

<span class="sd">        :param x: ndarray, the guess/sol</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># this row is the case when numDefectDyn are imposed in G rather than A</span>
        <span class="c1"># dynG = self.sys.nG * self.nPoint + (20 * self.dimdyn + 3*(self.dimu + self.dimp)) * (self.N - 1)</span>
        <span class="n">dynG</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sys</span><span class="o">.</span><span class="n">nG</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nPoint</span>
        <span class="n">usex</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">dimpoint</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sys</span><span class="o">.</span><span class="n">findTimeGradient</span><span class="p">(</span><span class="n">usex</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">sys</span><span class="o">.</span><span class="n">autonomous</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timeindex</span><span class="p">)</span>
            <span class="n">dynG</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nPoint</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">n</span>
        <span class="c1"># dynG arising from defect constraints</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixTimeMode</span><span class="p">:</span>
            <span class="n">dynG</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">daeOrder</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimdyn</span>  <span class="c1"># those are purely from the defect matrix</span>
            <span class="n">dynG</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numT</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">daeOrder</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimdyn</span> <span class="o">*</span> <span class="mi">2</span>  <span class="c1"># since time is free</span>
        <span class="k">return</span> <span class="n">dynG</span>

    <span class="k">def</span> <span class="nf">__getObjSparsity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set sparsity structure of the problem from objective function.</span>

<span class="sd">        The objective function pattern is composed of two parts:</span>
<span class="sd">        - linear parts. We sum all the coefficients and find sparsity pattern out of it</span>
<span class="sd">        - nonlinear parts. Each nonlinear objective is augmented with another row in jacobian</span>
<span class="sd">        and a another auxiliary optimization variable s.t. c(x) = y and J += y</span>

<span class="sd">        :param x: ndarray, the guess/sol</span>
<span class="sd">        :returns: nG: int, # Jacobian from nonlinear objective function</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">h</span><span class="p">,</span> <span class="n">useT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_time_grid__</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">useX</span><span class="p">,</span> <span class="n">useU</span><span class="p">,</span> <span class="n">useP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parseX__</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nPoint</span><span class="p">)</span>
        <span class="n">tmpx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="n">useT</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">useX</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">useU</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">useP</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
        <span class="n">nG</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># check sparseObj mode</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lqrObj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nG</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LQRnG</span>  <span class="c1"># this is always changing with time so do not worry</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonLinObj</span><span class="p">:</span>
            <span class="n">nG</span> <span class="o">+=</span> <span class="n">obj</span><span class="o">.</span><span class="n">nG</span>  <span class="c1"># this assume user knows preciously what is going on so do not care</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonPointObj</span><span class="p">:</span>
            <span class="n">nG</span> <span class="o">+=</span> <span class="n">obj</span><span class="o">.</span><span class="n">nG</span>  <span class="c1"># in this case, if not autonomous, depending on numT, we might have to</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">findTimeGradient</span><span class="p">(</span><span class="n">tmpx</span><span class="p">)</span>  <span class="c1"># detect pattern</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">obj</span><span class="o">.</span><span class="n">autonomous</span><span class="p">:</span>  <span class="c1"># since it is objective, only one piece is time, we have counted it once</span>
                <span class="n">nG</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># so if numT=0, we remove it, 1 is fine, 2 we increase one more</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonPathObj</span><span class="p">:</span>
            <span class="n">nG</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nPoint</span> <span class="o">*</span> <span class="n">obj</span><span class="o">.</span><span class="n">nG</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">findTimeGradient</span><span class="p">(</span><span class="n">tmpx</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">obj</span><span class="o">.</span><span class="n">autonomous</span><span class="p">:</span>
                <span class="n">nG</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nPoint</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># this is okay, I guess</span>
        <span class="k">return</span> <span class="n">nG</span>

    <span class="k">def</span> <span class="nf">__getTimeIndices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Utility function for assigning sparsity structure.&quot;&quot;&quot;</span>
        <span class="n">t0ind</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">tfind</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">lenX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nPoint</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimpoint</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixt0</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixtf</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tfind</span> <span class="o">=</span> <span class="n">lenX</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixtf</span><span class="p">:</span>
                <span class="n">t0ind</span> <span class="o">=</span> <span class="n">lenX</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">t0ind</span> <span class="o">=</span> <span class="n">lenX</span>
                <span class="n">tfind</span> <span class="o">=</span> <span class="n">lenX</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">t0ind</span><span class="p">,</span> <span class="n">tfind</span>

    <span class="k">def</span> <span class="nf">__setXbound__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set bounds on decision variables.&quot;&quot;&quot;</span>
        <span class="c1"># create bound on x</span>
        <span class="n">dimpnt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimpoint</span>
        <span class="n">dimx</span><span class="p">,</span> <span class="n">dimu</span><span class="p">,</span> <span class="n">dimp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimp</span>
        <span class="n">xlb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numSol</span><span class="p">)</span>
        <span class="n">xub</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numSol</span><span class="p">)</span>
        <span class="n">Mxlb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">xlb</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">numDynVar</span><span class="p">],</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nPoint</span><span class="p">,</span> <span class="n">dimpnt</span><span class="p">))</span>
        <span class="n">Mxub</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">xub</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">numDynVar</span><span class="p">],</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nPoint</span><span class="p">,</span> <span class="n">dimpnt</span><span class="p">))</span>
        <span class="n">Mulb</span> <span class="o">=</span> <span class="n">Mxlb</span><span class="p">[:,</span> <span class="n">dimx</span><span class="p">:</span><span class="n">dimx</span><span class="o">+</span><span class="n">dimu</span><span class="p">]</span>
        <span class="n">Muub</span> <span class="o">=</span> <span class="n">Mxub</span><span class="p">[:,</span> <span class="n">dimx</span><span class="p">:</span><span class="n">dimx</span><span class="o">+</span><span class="n">dimu</span><span class="p">]</span>
        <span class="n">Mplb</span> <span class="o">=</span> <span class="n">Mxlb</span><span class="p">[:,</span> <span class="n">dimpnt</span><span class="o">-</span><span class="n">dimp</span><span class="p">:</span><span class="n">dimpnt</span><span class="p">]</span>
        <span class="n">Mpub</span> <span class="o">=</span> <span class="n">Mxub</span><span class="p">[:,</span> <span class="n">dimpnt</span><span class="o">-</span><span class="n">dimp</span><span class="p">:</span><span class="n">dimpnt</span><span class="p">]</span>
        <span class="c1"># set bounds for q and dq, agree with previous convention</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">xbd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Mxlb</span><span class="p">[:,</span> <span class="p">:</span><span class="n">dimx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xbd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Mxlb</span><span class="p">[:,</span> <span class="p">:</span><span class="n">dimx</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1e20</span>
        <span class="c1"># set lb for x0 and xf</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0bd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Mxlb</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:</span><span class="n">dimx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0bd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">xfbd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Mxlb</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="n">dimx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xfbd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">xbd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Mxub</span><span class="p">[:,</span> <span class="p">:</span><span class="n">dimx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xbd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Mxub</span><span class="p">[:,</span> <span class="p">:</span><span class="n">dimx</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e20</span>
        <span class="c1"># set ub for x0 and xf</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0bd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Mxub</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:</span><span class="n">dimx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0bd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">xfbd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Mxub</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="n">dimx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xfbd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># set bounds for control variable</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ubd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Mulb</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ubd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Mulb</span><span class="p">[:]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1e20</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ubd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Muub</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ubd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Muub</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">1e20</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">Mplb</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Mplb</span><span class="p">[:]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1e20</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">Mpub</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Mpub</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">1e20</span>

        <span class="c1"># set bound on time</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixt0</span><span class="p">:</span>
            <span class="n">xlb</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">t0ind</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">xub</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">t0ind</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixtf</span><span class="p">:</span>
            <span class="n">xlb</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tfind</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">xub</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tfind</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># set bound on addX</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lenAddX</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">curN</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numTraj</span>
            <span class="k">for</span> <span class="n">addx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">addX</span><span class="p">:</span>
                <span class="n">xlb</span><span class="p">[</span><span class="n">curN</span><span class="p">:</span> <span class="n">curN</span> <span class="o">+</span> <span class="n">addx</span><span class="o">.</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">addx</span><span class="o">.</span><span class="n">lb</span>
                <span class="n">xub</span><span class="p">[</span><span class="n">curN</span><span class="p">:</span> <span class="n">curN</span> <span class="o">+</span> <span class="n">addx</span><span class="o">.</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">addx</span><span class="o">.</span><span class="n">ub</span>

        <span class="c1"># set bound on objaddn, this is obvious</span>
        <span class="n">xlb</span><span class="p">[</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">objaddn</span><span class="p">:]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1e20</span>
        <span class="n">xub</span><span class="p">[</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">objaddn</span><span class="p">:]</span> <span class="o">=</span> <span class="mf">1e20</span>

        <span class="c1"># assign to where it should belong to</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_xlb</span><span class="p">(</span><span class="n">xlb</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_xub</span><span class="p">(</span><span class="n">xub</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setFbound__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set bound on F&quot;&quot;&quot;</span>
        <span class="c1"># set bound on F</span>
        <span class="n">numF</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numF</span>
        <span class="n">numDyn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numDyn</span>
        <span class="n">clb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">numF</span><span class="p">)</span>
        <span class="n">cub</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">numF</span><span class="p">)</span>
        <span class="n">clb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1e20</span>
        <span class="n">cub</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e20</span>
        <span class="n">cind0</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">numDyn</span>
        <span class="n">cind0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_setNonLinConstr</span><span class="p">(</span><span class="n">clb</span><span class="p">,</span> <span class="n">cub</span><span class="p">,</span> <span class="n">cind0</span><span class="p">)</span>
        <span class="n">cind0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_setLinConstr</span><span class="p">(</span><span class="n">clb</span><span class="p">,</span> <span class="n">cub</span><span class="p">,</span> <span class="n">cind0</span><span class="p">)</span>
        <span class="c1"># the bounds for objaddn is 0 so we are good so far</span>
        <span class="c1"># assign to where it should belong to</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lb</span> <span class="o">=</span> <span class="n">clb</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ub</span> <span class="o">=</span> <span class="n">cub</span>

    <span class="k">def</span> <span class="nf">_setNonLinConstr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clb</span><span class="p">,</span> <span class="n">cub</span><span class="p">,</span> <span class="n">cind0</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">constr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointConstr</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">constr</span><span class="o">.</span><span class="n">lb</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">clb</span><span class="p">[</span><span class="n">cind0</span><span class="p">:</span> <span class="n">cind0</span> <span class="o">+</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span><span class="p">]</span> <span class="o">=</span> <span class="n">constr</span><span class="o">.</span><span class="n">lb</span>
            <span class="k">if</span> <span class="n">constr</span><span class="o">.</span><span class="n">ub</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">cub</span><span class="p">[</span><span class="n">cind0</span><span class="p">:</span> <span class="n">cind0</span> <span class="o">+</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span><span class="p">]</span> <span class="o">=</span> <span class="n">constr</span><span class="o">.</span><span class="n">ub</span>
            <span class="n">cind0</span> <span class="o">+=</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span>
        <span class="k">for</span> <span class="n">constr</span><span class="p">,</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pathConstr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pathConstrIndexPairs</span><span class="p">):</span>
            <span class="n">tmpN</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">colloc_constr_is_on</span><span class="p">:</span>
                <span class="n">useN</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">tmpN</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">useN</span> <span class="o">=</span> <span class="n">tmpN</span>
            <span class="n">tmplb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">clb</span><span class="p">[</span><span class="n">cind0</span><span class="p">:</span> <span class="n">cind0</span> <span class="o">+</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span> <span class="o">*</span> <span class="n">useN</span><span class="p">],</span> <span class="p">(</span><span class="n">useN</span><span class="p">,</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span><span class="p">))</span>
            <span class="n">tmpub</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">cub</span><span class="p">[</span><span class="n">cind0</span><span class="p">:</span> <span class="n">cind0</span> <span class="o">+</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span> <span class="o">*</span> <span class="n">useN</span><span class="p">],</span> <span class="p">(</span><span class="n">useN</span><span class="p">,</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span><span class="p">))</span>
            <span class="n">cind0</span> <span class="o">+=</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span> <span class="o">*</span> <span class="n">useN</span>
            <span class="k">if</span> <span class="n">constr</span><span class="o">.</span><span class="n">lb</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">tmplb</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">constr</span><span class="o">.</span><span class="n">lb</span>
            <span class="k">if</span> <span class="n">constr</span><span class="o">.</span><span class="n">ub</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">tmpub</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">constr</span><span class="o">.</span><span class="n">ub</span>
        <span class="k">for</span> <span class="n">constr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonLinConstr</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">constr</span><span class="o">.</span><span class="n">lb</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">clb</span><span class="p">[</span><span class="n">cind0</span><span class="p">:</span> <span class="n">cind0</span> <span class="o">+</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span><span class="p">]</span> <span class="o">=</span> <span class="n">constr</span><span class="o">.</span><span class="n">lb</span>
            <span class="k">if</span> <span class="n">constr</span><span class="o">.</span><span class="n">ub</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">cub</span><span class="p">[</span><span class="n">cind0</span><span class="p">:</span> <span class="n">cind0</span> <span class="o">+</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span><span class="p">]</span> <span class="o">=</span> <span class="n">constr</span><span class="o">.</span><span class="n">ub</span>
            <span class="n">cind0</span> <span class="o">+=</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span>
        <span class="k">return</span> <span class="n">cind0</span>

    <span class="k">def</span> <span class="nf">_setLinConstr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clb</span><span class="p">,</span> <span class="n">cub</span><span class="p">,</span> <span class="n">cind0</span><span class="p">):</span>
        <span class="c1"># the rest are linear constraints and we should write those bounds, too</span>
        <span class="k">for</span> <span class="n">constr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">linPointConstr</span><span class="p">:</span>
            <span class="n">cindf</span> <span class="o">=</span> <span class="n">cind0</span> <span class="o">+</span> <span class="n">constr</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">clb</span><span class="p">[</span><span class="n">cind0</span><span class="p">:</span> <span class="n">cindf</span><span class="p">]</span> <span class="o">=</span> <span class="n">constr</span><span class="o">.</span><span class="n">lb</span>
            <span class="n">cub</span><span class="p">[</span><span class="n">cind0</span><span class="p">:</span> <span class="n">cindf</span><span class="p">]</span> <span class="o">=</span> <span class="n">constr</span><span class="o">.</span><span class="n">ub</span>
            <span class="n">cind0</span> <span class="o">=</span> <span class="n">cindf</span>
        <span class="k">for</span> <span class="n">constr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">linPathConstr</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">colloc_constr_is_on</span><span class="p">:</span>
                <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nPoint</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span>
            <span class="n">cindf</span> <span class="o">=</span> <span class="n">cind0</span> <span class="o">+</span> <span class="n">N</span> <span class="o">*</span> <span class="n">constr</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">clb</span><span class="p">[</span><span class="n">cind0</span><span class="p">:</span> <span class="n">cindf</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">constr</span><span class="o">.</span><span class="n">lb</span><span class="p">,</span> <span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="n">cub</span><span class="p">[</span><span class="n">cind0</span><span class="p">:</span> <span class="n">cindf</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">constr</span><span class="o">.</span><span class="n">ub</span><span class="p">,</span> <span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="n">cind0</span> <span class="o">=</span> <span class="n">cindf</span>
        <span class="k">for</span> <span class="n">constr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">linearConstr</span><span class="p">:</span>
            <span class="n">cindf</span> <span class="o">=</span> <span class="n">cind0</span> <span class="o">+</span> <span class="n">constr</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">clb</span><span class="p">[</span><span class="n">cind0</span><span class="p">:</span> <span class="n">cindf</span><span class="p">]</span> <span class="o">=</span> <span class="n">constr</span><span class="o">.</span><span class="n">lb</span>
            <span class="n">cub</span><span class="p">[</span><span class="n">cind0</span><span class="p">:</span> <span class="n">cindf</span><span class="p">]</span> <span class="o">=</span> <span class="n">constr</span><span class="o">.</span><span class="n">ub</span>
            <span class="n">cind0</span> <span class="o">=</span> <span class="n">cindf</span>
        <span class="k">return</span> <span class="n">cind0</span>

    <span class="k">def</span> <span class="nf">__get_time_grid__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Based on initial guess x, get the time grid for discretization.</span>

<span class="sd">        :param x: ndarray, the guess/sol.</span>
<span class="sd">        :returns: h: float, grid size</span>
<span class="sd">        :returns: useT: the grid being used</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixt0</span><span class="p">:</span>
            <span class="n">uset0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">uset0</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">t0ind</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixtf</span><span class="p">:</span>
            <span class="n">usetf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tf</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">usetf</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tfind</span><span class="p">]</span>
        <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">usetf</span> <span class="o">-</span> <span class="n">uset0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">useT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">uset0</span><span class="p">,</span> <span class="n">usetf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nPoint</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">h</span><span class="p">,</span> <span class="n">useT</span>

    <span class="k">def</span> <span class="nf">__parseX__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Parse guess/sol into X, U, P&quot;&quot;&quot;</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">numDynVar</span><span class="p">],</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nPoint</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimpoint</span><span class="p">))</span>
        <span class="n">useX</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span> <span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">dimx</span><span class="p">]</span>
        <span class="n">useU</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">dimpoint</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimp</span><span class="p">]</span>
        <span class="n">useP</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimpoint</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimp</span><span class="p">:]</span>
        <span class="k">return</span> <span class="n">useX</span><span class="p">,</span> <span class="n">useU</span><span class="p">,</span> <span class="n">useP</span>

<div class="viewcode-block" id="trajOptCollocProblem.parseF"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptCollocationProblem.trajOptCollocProblem.parseF">[docs]</a>    <span class="k">def</span> <span class="nf">parseF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">guess</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Give an guess, evaluate it and parse into parts.</span>

<span class="sd">        :param guess: ndarray, (numSol, ) a guess or a solution to check</span>
<span class="sd">        :param y: ndarray, (numF, ) if None, it stores the solution</span>
<span class="sd">        :returns: dict, containing objective and parsed constraints</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">guess</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">numSol</span>
        <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span>
        <span class="n">nPoint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nPoint</span>
        <span class="n">dimx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span>
        <span class="n">dimdyn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimdyn</span>
        <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numF</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__callg__</span><span class="p">(</span><span class="n">guess</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__callf__</span><span class="p">(</span><span class="n">guess</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spA</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">guess</span><span class="p">)</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dynCon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">:(</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">dimdyn</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dimdyn</span><span class="p">))</span>
        <span class="n">curN</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">dimdyn</span>
        <span class="n">curNf</span> <span class="o">=</span> <span class="n">curN</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynDefectSize</span> <span class="o">*</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">defectCon</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">dynDefectCon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">curN</span><span class="p">:</span> <span class="n">curNf</span><span class="p">],</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">defectCon</span><span class="p">[</span><span class="s1">&#39;dyn&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dynDefectCon</span>
        <span class="n">curN</span> <span class="o">=</span> <span class="n">curNf</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">defectU</span><span class="p">:</span>
            <span class="n">dimu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimu</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dimu</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">defectP</span><span class="p">:</span>
            <span class="n">dimp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dimp</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">curNf</span> <span class="o">+=</span> <span class="p">(</span><span class="n">dimu</span> <span class="o">+</span> <span class="n">dimp</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">upDefectCon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">curN</span><span class="p">:</span> <span class="n">curNf</span><span class="p">],</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">dimu</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">defectCon</span><span class="p">[</span><span class="s1">&#39;u&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">upDefectCon</span><span class="p">[:,</span> <span class="p">:</span><span class="n">dimu</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">dimp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">defectCon</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">upDefectCon</span><span class="p">[:,</span> <span class="n">dimu</span><span class="p">:</span><span class="n">dimu</span><span class="o">+</span><span class="n">dimp</span><span class="p">]</span>

        <span class="n">curN</span> <span class="o">=</span> <span class="n">curNf</span>
        <span class="n">pointCon</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">constr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointConstr</span><span class="p">:</span>
            <span class="n">pointCon</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">curN</span><span class="p">:</span> <span class="n">curN</span> <span class="o">+</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span><span class="p">])</span>
            <span class="n">curN</span> <span class="o">+=</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span>
        <span class="n">pathCon</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">constr</span><span class="p">,</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pathConstr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pathConstrIndexPairs</span><span class="p">):</span>
            <span class="n">tmpN</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">colloc_constr_is_on</span><span class="p">:</span>
                <span class="n">useN</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">tmpN</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">useN</span> <span class="o">=</span> <span class="n">tmpN</span>
            <span class="n">pathCon</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">curN</span><span class="p">:</span> <span class="n">curN</span><span class="o">+</span><span class="n">useN</span><span class="o">*</span><span class="n">constr</span><span class="o">.</span><span class="n">nf</span><span class="p">],</span> <span class="p">(</span><span class="n">useN</span><span class="p">,</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span><span class="p">)))</span>
            <span class="n">curN</span> <span class="o">+=</span> <span class="n">useN</span><span class="o">*</span><span class="n">constr</span><span class="o">.</span><span class="n">nf</span>
        <span class="n">nonLinCon</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">constr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonLinConstr</span><span class="p">:</span>
            <span class="n">nonLinCon</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">curN</span><span class="p">:</span> <span class="n">curN</span><span class="o">+</span><span class="n">constr</span><span class="o">.</span><span class="n">nf</span><span class="p">])</span>
            <span class="n">curN</span> <span class="o">+=</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span>
        <span class="c1"># all linear constraints can be ignored, here we ignore them</span>
        <span class="c1"># check bounds, return a -1, 1 value for non-equality bounds, and 0 for equality bounds</span>
        <span class="n">useX</span><span class="p">,</span> <span class="n">useU</span><span class="p">,</span> <span class="n">useP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parseX__</span><span class="p">(</span><span class="n">guess</span><span class="p">)</span>
        <span class="n">Xbound</span> <span class="o">=</span> <span class="n">checkInBounds</span><span class="p">(</span><span class="n">useX</span><span class="p">[:,</span> <span class="p">:</span><span class="n">dimx</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">xbd</span><span class="p">)</span>
        <span class="n">x0bound</span> <span class="o">=</span> <span class="n">checkInBounds</span><span class="p">(</span><span class="n">useX</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:</span><span class="n">dimx</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0bd</span><span class="p">)</span>
        <span class="n">xfbound</span> <span class="o">=</span> <span class="n">checkInBounds</span><span class="p">(</span><span class="n">useX</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="n">dimx</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">xfbd</span><span class="p">)</span>
        <span class="n">ubound</span> <span class="o">=</span> <span class="n">checkInBounds</span><span class="p">(</span><span class="n">useU</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ubd</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">pbound</span> <span class="o">=</span> <span class="n">checkInBounds</span><span class="p">(</span><span class="n">useP</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbd</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pbound</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0ind</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">t0bound</span> <span class="o">=</span> <span class="n">checkInBounds</span><span class="p">(</span><span class="n">guess</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">t0ind</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">t0bound</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tfind</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">tfbound</span> <span class="o">=</span> <span class="n">checkInBounds</span><span class="p">(</span><span class="n">guess</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tfind</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">tf</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tfbound</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lenAddX</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">addx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parseAddX__</span><span class="p">(</span><span class="n">guess</span><span class="p">)</span>
            <span class="n">addXbound</span> <span class="o">=</span> <span class="p">[</span><span class="n">checkInBounds</span><span class="p">(</span><span class="n">addx_</span><span class="p">,</span> <span class="p">[</span><span class="n">addx__</span><span class="o">.</span><span class="n">lb</span><span class="p">,</span> <span class="n">addx__</span><span class="o">.</span><span class="n">ub</span><span class="p">])</span> <span class="k">for</span> <span class="n">addx_</span><span class="p">,</span> <span class="n">addx__</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">addx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">addX</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">addXbound</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">useX</span><span class="p">,</span> <span class="n">useU</span><span class="p">,</span> <span class="n">useP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parseX__</span><span class="p">(</span><span class="n">guess</span><span class="p">)</span>
        <span class="n">objs</span> <span class="o">=</span> <span class="n">guess</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">numSol</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">objaddn</span><span class="p">:]</span>
        <span class="n">rst</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;obj&#39;</span><span class="p">:</span> <span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;objs&#39;</span><span class="p">:</span> <span class="n">objs</span><span class="p">,</span> <span class="s1">&#39;dyn&#39;</span><span class="p">:</span> <span class="n">dynCon</span><span class="p">,</span> <span class="s1">&#39;defect&#39;</span><span class="p">:</span> <span class="n">defectCon</span><span class="p">,</span> <span class="s1">&#39;point&#39;</span><span class="p">:</span> <span class="n">pointCon</span><span class="p">,</span> <span class="s1">&#39;path&#39;</span><span class="p">:</span> <span class="n">pathCon</span><span class="p">,</span> <span class="s1">&#39;nonlin&#39;</span><span class="p">:</span> <span class="n">nonLinCon</span><span class="p">,</span>
                <span class="s1">&#39;xbd&#39;</span><span class="p">:</span> <span class="n">Xbound</span><span class="p">,</span> <span class="s1">&#39;ubd&#39;</span><span class="p">:</span> <span class="n">ubound</span><span class="p">,</span> <span class="s1">&#39;x0bd&#39;</span><span class="p">:</span> <span class="n">x0bound</span><span class="p">,</span> <span class="s1">&#39;xfbd&#39;</span><span class="p">:</span> <span class="n">xfbound</span><span class="p">,</span> <span class="s1">&#39;pbd&#39;</span><span class="p">:</span> <span class="n">pbound</span><span class="p">,</span>
                <span class="s1">&#39;t0bd&#39;</span><span class="p">:</span> <span class="n">t0bound</span><span class="p">,</span> <span class="s1">&#39;tfbd&#39;</span><span class="p">:</span> <span class="n">tfbound</span><span class="p">,</span> <span class="s1">&#39;addXbd&#39;</span><span class="p">:</span> <span class="n">addXbound</span><span class="p">,</span>
                <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="n">useX</span><span class="p">,</span> <span class="s1">&#39;u&#39;</span><span class="p">:</span> <span class="n">useU</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">:</span> <span class="n">useP</span><span class="p">}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0ind</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">rst</span><span class="p">[</span><span class="s1">&#39;t0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">guess</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">t0ind</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rst</span><span class="p">[</span><span class="s1">&#39;t0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tfind</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">rst</span><span class="p">[</span><span class="s1">&#39;tf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">guess</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tfind</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rst</span><span class="p">[</span><span class="s1">&#39;tf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tf</span>
        <span class="n">rst</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">rst</span><span class="p">[</span><span class="s1">&#39;t0&#39;</span><span class="p">],</span> <span class="n">rst</span><span class="p">[</span><span class="s1">&#39;tf&#39;</span><span class="p">],</span> <span class="mi">2</span><span class="o">*</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># parse addx</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lenAddX</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">addx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parseAddX__</span><span class="p">(</span><span class="n">guess</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">addx_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">addx</span><span class="p">):</span>
                <span class="n">rst</span><span class="p">[</span><span class="s1">&#39;addx_</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">addx_</span>
        <span class="k">return</span> <span class="n">rst</span></div>

    <span class="k">def</span> <span class="nf">__parseAddX__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">numTraj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numTraj</span>
        <span class="n">addX</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">addx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">addX</span><span class="p">:</span>
            <span class="n">addX</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">numTraj</span><span class="p">:</span> <span class="n">numTraj</span> <span class="o">+</span> <span class="n">addx</span><span class="o">.</span><span class="n">n</span><span class="p">])</span>
            <span class="n">numTraj</span> <span class="o">+=</span> <span class="n">addx</span><span class="o">.</span><span class="n">n</span>
        <span class="k">return</span> <span class="n">addX</span>

    <span class="k">def</span> <span class="nf">__parseObj__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">numSol</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">objaddn</span><span class="p">:]</span>

<div class="viewcode-block" id="trajOptCollocProblem.getAddXIndexByIndex"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptCollocationProblem.trajOptCollocProblem.getAddXIndexByIndex">[docs]</a>    <span class="k">def</span> <span class="nf">getAddXIndexByIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;With i as index of addx, it returns the starting index in solution vector for this one.</span>

<span class="sd">        :param i: int, the index of addX we want to query.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numTraj</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">addX</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">n</span>
        <span class="k">return</span> <span class="n">index</span></div>

<div class="viewcode-block" id="trajOptCollocProblem.getStateIndexByIndex"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptCollocationProblem.trajOptCollocProblem.getStateIndexByIndex">[docs]</a>    <span class="k">def</span> <span class="nf">getStateIndexByIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;With i as index for state variable, return the starting index in solution vector.</span>

<span class="sd">        :param i: int, the index of State we want to query</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimpoint</span> <span class="o">*</span> <span class="n">i</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nPoint</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimpoint</span></div>

<div class="viewcode-block" id="trajOptCollocProblem.getContrlIndexByIndex"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptCollocationProblem.trajOptCollocProblem.getContrlIndexByIndex">[docs]</a>    <span class="k">def</span> <span class="nf">getContrlIndexByIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;With i as index for control variable, return the starting index in solution vector.</span>

<span class="sd">        :param i: int, the index of control we want to query</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimpoint</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nPoint</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimpoint</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span></div>

<div class="viewcode-block" id="trajOptCollocProblem.getParamIndexByIndex"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptCollocationProblem.trajOptCollocProblem.getParamIndexByIndex">[docs]</a>    <span class="k">def</span> <span class="nf">getParamIndexByIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;With i as index for parameter variable, return the starting index in solution vector.</span>

<span class="sd">        :param i: int, the index of parameter we want to query</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimpoint</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimu</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nPoint</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimpoint</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimu</span></div>

<div class="viewcode-block" id="trajOptCollocProblem.__callg__"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptCollocationProblem.trajOptCollocProblem.__callg__">[docs]</a>    <span class="k">def</span> <span class="nf">__callg__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span> <span class="n">needg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate those constraints, objective functions, and constraints. It simultaneously allocates sparsity matrix.</span>

<span class="sd">        :param x: ndarray, the solution to the problem</span>
<span class="sd">        :param y: ndarray, return F</span>
<span class="sd">        :param G/row/col: ndarray, information of gradient</span>
<span class="sd">        :param rec/needg: if we record/ if we need gradient</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># since this row is purely linear</span>
        <span class="n">h</span><span class="p">,</span> <span class="n">useT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_time_grid__</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">useX</span><span class="p">,</span> <span class="n">useU</span><span class="p">,</span> <span class="n">useP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parseX__</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="c1"># loop over all system dynamics constraint</span>
        <span class="n">curRow</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">curNg</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">curRow</span><span class="p">,</span> <span class="n">curNg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dynconstr_mode_g__</span><span class="p">(</span><span class="n">curRow</span><span class="p">,</span> <span class="n">curNg</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">useT</span><span class="p">,</span> <span class="n">useX</span><span class="p">,</span> <span class="n">useU</span><span class="p">,</span> <span class="n">useP</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span> <span class="n">needg</span><span class="p">)</span>
        <span class="n">curRow</span><span class="p">,</span> <span class="n">curNg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__constr_mode_g__</span><span class="p">(</span><span class="n">curRow</span><span class="p">,</span> <span class="n">curNg</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">useT</span><span class="p">,</span> <span class="n">useX</span><span class="p">,</span> <span class="n">useU</span><span class="p">,</span> <span class="n">useP</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span> <span class="n">needg</span><span class="p">)</span>
        <span class="n">curRow</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numLinCon</span>
        <span class="c1"># loop over all the objective functions, I haven&#39;t checked if order is correct since some linear constraints are followed</span>
        <span class="n">curRow</span><span class="p">,</span> <span class="n">curNg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__obj_mode_g__</span><span class="p">(</span><span class="n">curRow</span><span class="p">,</span> <span class="n">curNg</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">useT</span><span class="p">,</span> <span class="n">useX</span><span class="p">,</span> <span class="n">useU</span><span class="p">,</span> <span class="n">useP</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span> <span class="n">needg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">curRow</span><span class="p">,</span> <span class="n">curNg</span></div>

    <span class="k">def</span> <span class="nf">__dynconstr_mode_g__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">curRow</span><span class="p">,</span> <span class="n">curNg</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">useT</span><span class="p">,</span> <span class="n">useX</span><span class="p">,</span> <span class="n">useU</span><span class="p">,</span> <span class="n">useP</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span> <span class="n">needg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate the constraints imposed by system dynamics&quot;&quot;&quot;</span>
        <span class="n">dimx</span><span class="p">,</span> <span class="n">dimu</span><span class="p">,</span> <span class="n">dimp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimp</span>
        <span class="n">dimpoint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimpoint</span>
        <span class="n">dimdyn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimdyn</span>  <span class="c1"># this works for many cases</span>
        <span class="n">nPoint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nPoint</span>
        <span class="c1"># first let&#39;s check the 2*N - 1 dimdyn constraints from dynamics</span>
        <span class="n">cDyn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">curRow</span><span class="p">:</span><span class="n">curRow</span> <span class="o">+</span> <span class="n">nPoint</span> <span class="o">*</span> <span class="n">dimdyn</span><span class="p">],</span> <span class="p">(</span><span class="n">nPoint</span><span class="p">,</span> <span class="n">dimdyn</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nPoint</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sys</span><span class="o">.</span><span class="n">autonomous</span><span class="p">:</span>
                <span class="n">Gpiece</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">sys</span><span class="o">.</span><span class="n">nG</span><span class="p">]</span>
                <span class="n">rowpiece</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">sys</span><span class="o">.</span><span class="n">nG</span><span class="p">]</span>
                <span class="n">colpiece</span> <span class="o">=</span> <span class="n">col</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">sys</span><span class="o">.</span><span class="n">nG</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sys</span><span class="o">.</span><span class="n">dyn</span><span class="p">(</span><span class="n">useT</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">useX</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">useU</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">useP</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cDyn</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Gpiece</span><span class="p">,</span> <span class="n">rowpiece</span><span class="p">,</span> <span class="n">colpiece</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span> <span class="n">needg</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">needg</span><span class="p">:</span>
                    <span class="n">curNg</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sys</span><span class="o">.</span><span class="n">nG</span>
                    <span class="k">if</span> <span class="n">rec</span><span class="p">:</span>
                        <span class="n">rowpiece</span><span class="p">[:]</span> <span class="o">+=</span> <span class="n">curRow</span>
                        <span class="n">colpiece</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__patchCol__</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">colpiece</span><span class="p">[:])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sys</span><span class="o">.</span><span class="n">dyn</span><span class="p">(</span><span class="n">useT</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">useX</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">useU</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">useP</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cDyn</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span> <span class="n">needg</span><span class="p">)</span>
                <span class="n">curNg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__copy_into_g__</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">curRow</span><span class="p">,</span> <span class="n">curNg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sys</span><span class="o">.</span><span class="n">nG</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sys</span><span class="o">.</span><span class="n">timeindex</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span>
                                             <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">)</span>
            <span class="n">curRow</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimdyn</span>
        <span class="c1"># offset of row number due to defect dynamics constraint</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixTimeMode</span><span class="p">:</span>
            <span class="n">curRow</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numDefectDyn</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># manually set those defect dynamics and gradients, etc</span>
            <span class="n">defectRow</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">daeOrder</span> <span class="o">*</span> <span class="n">dimdyn</span>
            <span class="n">cDefect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">curRow</span><span class="p">:</span> <span class="n">curRow</span> <span class="o">+</span> <span class="n">defectRow</span><span class="p">],</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">daeOrder</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">dimdyn</span><span class="p">))</span>
            <span class="n">bscIndex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dimdyn</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">lefti</span><span class="p">,</span> <span class="n">righti</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">daeOrder</span><span class="p">):</span>
                    <span class="n">cDefect</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">h</span><span class="o">/</span><span class="mi">8</span> <span class="o">*</span> <span class="n">useX</span><span class="p">[</span><span class="n">lefti</span><span class="p">,</span> <span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">dimdyn</span><span class="p">:(</span><span class="n">j</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">dimdyn</span><span class="p">]</span> <span class="o">-</span> <span class="n">h</span><span class="o">/</span><span class="mi">8</span> <span class="o">*</span> <span class="n">useX</span><span class="p">[</span><span class="n">righti</span><span class="p">,</span> <span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">dimdyn</span><span class="p">:(</span><span class="n">j</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">dimdyn</span><span class="p">]</span>
                    <span class="n">cDefect</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.5</span><span class="o">/</span><span class="n">h</span> <span class="o">*</span> <span class="n">useX</span><span class="p">[</span><span class="n">lefti</span><span class="p">,</span> <span class="n">j</span><span class="o">*</span><span class="n">dimdyn</span><span class="p">:(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">dimdyn</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1.5</span><span class="o">/</span><span class="n">h</span> <span class="o">*</span> <span class="n">useX</span><span class="p">[</span><span class="n">righti</span><span class="p">,</span> <span class="n">j</span><span class="o">*</span><span class="n">dimdyn</span><span class="p">:(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">dimdyn</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">needg</span><span class="p">:</span>
                        <span class="n">G</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">dimdyn</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span> <span class="o">/</span> <span class="mi">8</span>
                        <span class="n">G</span><span class="p">[</span><span class="n">curNg</span> <span class="o">+</span> <span class="n">dimdyn</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">dimdyn</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">h</span> <span class="o">/</span> <span class="mi">8</span>
                        <span class="n">G</span><span class="p">[</span><span class="n">curNg</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">dimdyn</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">dimdyn</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.5</span> <span class="o">/</span> <span class="n">h</span>
                        <span class="n">G</span><span class="p">[</span><span class="n">curNg</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">dimdyn</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">dimdyn</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.5</span> <span class="o">/</span> <span class="n">h</span>
                        <span class="k">if</span> <span class="n">rec</span><span class="p">:</span>
                            <span class="n">row</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span><span class="n">curNg</span> <span class="o">+</span> <span class="n">dimdyn</span><span class="p">]</span> <span class="o">=</span> <span class="n">curRow</span> <span class="o">+</span> <span class="n">bscIndex</span> 
                            <span class="n">row</span><span class="p">[</span><span class="n">curNg</span> <span class="o">+</span> <span class="n">dimdyn</span><span class="p">:</span><span class="n">curNg</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">dimdyn</span><span class="p">]</span> <span class="o">=</span> <span class="n">curRow</span> <span class="o">+</span> <span class="n">bscIndex</span> 
                            <span class="n">col</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span><span class="n">curNg</span> <span class="o">+</span> <span class="n">dimdyn</span><span class="p">]</span> <span class="o">=</span> <span class="n">lefti</span> <span class="o">*</span> <span class="n">dimpoint</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">dimdyn</span> <span class="o">+</span> <span class="n">dimdyn</span> <span class="o">+</span> <span class="n">bscIndex</span>
                            <span class="n">col</span><span class="p">[</span><span class="n">curNg</span> <span class="o">+</span> <span class="n">dimdyn</span><span class="p">:</span><span class="n">curNg</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">dimdyn</span><span class="p">]</span> <span class="o">=</span> <span class="n">righti</span> <span class="o">*</span> <span class="n">dimpoint</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">dimdyn</span> <span class="o">+</span> <span class="n">dimdyn</span> <span class="o">+</span> <span class="n">bscIndex</span>
                            <span class="n">row</span><span class="p">[</span><span class="n">curNg</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">dimdyn</span><span class="p">:</span><span class="n">curNg</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">dimdyn</span><span class="p">]</span> <span class="o">=</span> <span class="n">curRow</span> <span class="o">+</span> <span class="n">bscIndex</span> <span class="o">+</span> <span class="n">dimdyn</span>
                            <span class="n">row</span><span class="p">[</span><span class="n">curNg</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">dimdyn</span><span class="p">:</span><span class="n">curNg</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">dimdyn</span><span class="p">]</span> <span class="o">=</span> <span class="n">curRow</span> <span class="o">+</span> <span class="n">bscIndex</span> <span class="o">+</span> <span class="n">dimdyn</span>
                            <span class="n">col</span><span class="p">[</span><span class="n">curNg</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">dimdyn</span><span class="p">:</span><span class="n">curNg</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">dimdyn</span><span class="p">]</span> <span class="o">=</span> <span class="n">lefti</span> <span class="o">*</span> <span class="n">dimpoint</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">dimdyn</span> <span class="o">+</span> <span class="n">bscIndex</span>
                            <span class="n">col</span><span class="p">[</span><span class="n">curNg</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">dimdyn</span><span class="p">:</span><span class="n">curNg</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">dimdyn</span><span class="p">]</span> <span class="o">=</span> <span class="n">righti</span> <span class="o">*</span> <span class="n">dimpoint</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">dimdyn</span> <span class="o">+</span> <span class="n">bscIndex</span>
                        <span class="n">curNg</span> <span class="o">+=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">dimdyn</span>
                        <span class="c1"># if time related, we have to also consider them</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixTimeMode</span><span class="p">:</span>
                            <span class="n">pc1pt</span> <span class="o">=</span> <span class="p">(</span><span class="n">useX</span><span class="p">[</span><span class="n">lefti</span><span class="p">,</span> <span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">dimdyn</span><span class="p">:(</span><span class="n">j</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">dimdyn</span><span class="p">]</span> <span class="o">-</span> <span class="n">useX</span><span class="p">[</span><span class="n">righti</span><span class="p">,</span> <span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">dimdyn</span><span class="p">:(</span><span class="n">j</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">dimdyn</span><span class="p">])</span> <span class="o">/</span> <span class="mi">8</span>
                            <span class="n">pc2pt</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="o">-</span><span class="n">useX</span><span class="p">[</span><span class="n">lefti</span><span class="p">,</span> <span class="n">j</span><span class="o">*</span><span class="n">dimdyn</span><span class="p">:(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">dimdyn</span><span class="p">]</span> <span class="o">+</span> <span class="n">useX</span><span class="p">[</span><span class="n">righti</span><span class="p">,</span> <span class="n">j</span><span class="o">*</span><span class="n">dimdyn</span><span class="p">:(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">dimdyn</span><span class="p">])</span> <span class="o">*</span> <span class="mf">1.5</span> <span class="o">/</span> <span class="n">h</span> <span class="o">**</span> <span class="mi">2</span>
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0ind</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="n">G</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">dimdyn</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">pc1pt</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                                <span class="n">G</span><span class="p">[</span><span class="n">curNg</span> <span class="o">+</span> <span class="n">dimdyn</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">dimdyn</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">pc2pt</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                                <span class="k">if</span> <span class="n">rec</span><span class="p">:</span>
                                    <span class="n">row</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">dimdyn</span><span class="p">]</span> <span class="o">=</span> <span class="n">curRow</span> <span class="o">+</span> <span class="n">bscIndex</span>
                                    <span class="n">row</span><span class="p">[</span><span class="n">curNg</span> <span class="o">+</span> <span class="n">dimdyn</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">dimdyn</span><span class="p">]</span> <span class="o">=</span> <span class="n">curRow</span> <span class="o">+</span> <span class="n">bscIndex</span> <span class="o">+</span> <span class="n">dimdyn</span>
                                    <span class="n">col</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">dimdyn</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0ind</span>
                                <span class="n">curNg</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">dimdyn</span>
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tfind</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="n">G</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">dimdyn</span><span class="p">]</span> <span class="o">=</span> <span class="n">pc1pt</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                                <span class="n">G</span><span class="p">[</span><span class="n">curNg</span> <span class="o">+</span> <span class="n">dimdyn</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">dimdyn</span><span class="p">]</span> <span class="o">=</span> <span class="n">pc2pt</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                                <span class="k">if</span> <span class="n">rec</span><span class="p">:</span>
                                    <span class="n">row</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">dimdyn</span><span class="p">]</span> <span class="o">=</span> <span class="n">curRow</span> <span class="o">+</span> <span class="n">bscIndex</span>
                                    <span class="n">row</span><span class="p">[</span><span class="n">curNg</span> <span class="o">+</span> <span class="n">dimdyn</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">dimdyn</span><span class="p">]</span> <span class="o">=</span> <span class="n">curRow</span> <span class="o">+</span> <span class="n">bscIndex</span> <span class="o">+</span> <span class="n">dimdyn</span>
                                    <span class="n">col</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">dimdyn</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tfind</span>
                                <span class="n">curNg</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">dimdyn</span>
                    <span class="n">curRow</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">dimdyn</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">defectU</span><span class="p">:</span>
                <span class="n">curRow</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimu</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">defectP</span><span class="p">:</span>
                <span class="n">curRow</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimp</span>
        <span class="k">return</span> <span class="n">curRow</span><span class="p">,</span> <span class="n">curNg</span>

    <span class="k">def</span> <span class="nf">__copy_into_g__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">curRow</span><span class="p">,</span> <span class="n">curNg</span><span class="p">,</span> <span class="n">nG</span><span class="p">,</span> <span class="n">time_index</span><span class="p">,</span> <span class="n">plus</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span>
                        <span class="n">G_src</span><span class="p">,</span> <span class="n">row_src</span><span class="p">,</span> <span class="n">col_src</span><span class="p">,</span> <span class="n">col_offset</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;With sparsity calculated in self.G, we assign to correct G.</span>

<span class="sd">        :param index: int, we are evaluating this at which point</span>
<span class="sd">        :param G, row, col: the G, row, col vector storing sparse Jacobian.</span>
<span class="sd">        :param curRow: accumulated row number.</span>
<span class="sd">        :param curNg: accumulated sparse Jacobian number</span>
<span class="sd">        :param nG: number of non-zero of Jacobian, this indicates how long of self.G we shall use</span>
<span class="sd">        :param timeindex: index indicating time related.</span>
<span class="sd">        :param plus: bool, if we plus value to time-related index (integral one)</span>
<span class="sd">        :param rec: bool, if we record index into row and col</span>
<span class="sd">        :param G_src/row_src/col_src: where we copy value from</span>
<span class="sd">        :param col_offset: int, offset of column, it is only used for multiple-phase problem</span>
<span class="sd">        :return curNg: updated occupied Ng</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># use time index to build the mask for selecting data</span>
        <span class="n">G_</span> <span class="o">=</span> <span class="n">G_src</span><span class="p">[:</span><span class="n">nG</span><span class="p">]</span>
        <span class="n">timemask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nG</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">timemask</span><span class="p">[</span><span class="n">time_index</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># get a mask for time-related gradient</span>
        <span class="n">statemask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">timemask</span><span class="p">)</span>
        <span class="n">lenstate</span> <span class="o">=</span> <span class="n">nG</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">time_index</span><span class="p">)</span>
        <span class="n">lenTime</span> <span class="o">=</span> <span class="n">nG</span> <span class="o">-</span> <span class="n">lenstate</span>
        <span class="n">G</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">lenstate</span><span class="p">]</span> <span class="o">=</span> <span class="n">G_</span><span class="p">[</span><span class="n">statemask</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">rec</span><span class="p">:</span>
            <span class="n">col_</span> <span class="o">=</span> <span class="n">col_src</span><span class="p">[:</span><span class="n">nG</span><span class="p">]</span>
            <span class="n">row_</span> <span class="o">=</span> <span class="n">row_src</span><span class="p">[:</span><span class="n">nG</span><span class="p">]</span>
            <span class="n">col</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">lenstate</span><span class="p">]</span> <span class="o">=</span> <span class="n">col_</span><span class="p">[</span><span class="n">statemask</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">index</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimpoint</span> <span class="o">+</span> <span class="n">col_offset</span>
            <span class="n">row</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">lenstate</span><span class="p">]</span> <span class="o">=</span> <span class="n">row_</span><span class="p">[</span><span class="n">statemask</span><span class="p">]</span> <span class="o">+</span> <span class="n">curRow</span>
        <span class="n">curNg</span> <span class="o">+=</span> <span class="n">lenstate</span>
        <span class="c1"># for time related columns</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0ind</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ptpt0</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">index</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">plus</span><span class="p">:</span>
                <span class="n">G</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">lenTime</span><span class="p">]</span> <span class="o">+=</span> <span class="n">G_</span><span class="p">[</span><span class="n">time_index</span><span class="p">]</span> <span class="o">*</span> <span class="n">ptpt0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">G</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">lenTime</span><span class="p">]</span> <span class="o">=</span> <span class="n">G_</span><span class="p">[</span><span class="n">time_index</span><span class="p">]</span> <span class="o">*</span> <span class="n">ptpt0</span>
            <span class="k">if</span> <span class="n">rec</span><span class="p">:</span>
                <span class="n">row</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">lenTime</span><span class="p">]</span> <span class="o">=</span> <span class="n">row_</span><span class="p">[</span><span class="n">time_index</span><span class="p">]</span> <span class="o">+</span> <span class="n">curRow</span>
                <span class="n">col</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">lenTime</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0ind</span> <span class="o">+</span> <span class="n">col_offset</span>
            <span class="n">curNg</span> <span class="o">+=</span> <span class="n">lenTime</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tfind</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ptptf</span> <span class="o">=</span> <span class="n">index</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">plus</span><span class="p">:</span>
                <span class="n">G</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">lenTime</span><span class="p">]</span> <span class="o">+=</span> <span class="n">G_</span><span class="p">[</span><span class="n">time_index</span><span class="p">]</span> <span class="o">*</span> <span class="n">ptptf</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">G</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">lenTime</span><span class="p">]</span> <span class="o">=</span> <span class="n">G_</span><span class="p">[</span><span class="n">time_index</span><span class="p">]</span> <span class="o">*</span> <span class="n">ptptf</span>
            <span class="k">if</span> <span class="n">rec</span><span class="p">:</span>
                <span class="n">row</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">lenTime</span><span class="p">]</span> <span class="o">=</span> <span class="n">row_</span><span class="p">[</span><span class="n">time_index</span><span class="p">]</span> <span class="o">+</span> <span class="n">curRow</span>
                <span class="n">col</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">lenTime</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tfind</span> <span class="o">+</span> <span class="n">col_offset</span>
            <span class="n">curNg</span> <span class="o">+=</span> <span class="n">lenTime</span>
        <span class="k">return</span> <span class="n">curNg</span>

    <span class="k">def</span> <span class="nf">__obj_mode_g__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">curRow</span><span class="p">,</span> <span class="n">curNg</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">useT</span><span class="p">,</span> <span class="n">useX</span><span class="p">,</span> <span class="n">useU</span><span class="p">,</span> <span class="n">useP</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span> <span class="n">needg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate objective function. Basically it moves all nonlinear objective function to the final rows</span>
<span class="sd">        See __constrModeG__ for arguments and output.&quot;&quot;&quot;</span>
        <span class="n">tmpout</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># first lets do lqrobj</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lqrObj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># the lqr obj</span>
            <span class="n">Gpiece</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">LQRnG</span><span class="p">]</span>
            <span class="n">rowpiece</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">LQRnG</span><span class="p">]</span>
            <span class="n">colpiece</span> <span class="o">=</span> <span class="n">col</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">LQRnG</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lqrObj</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">useX</span><span class="p">,</span> <span class="n">useU</span><span class="p">,</span> <span class="n">useP</span><span class="p">,</span> <span class="n">tmpout</span><span class="p">,</span> <span class="n">Gpiece</span><span class="p">,</span> <span class="n">rowpiece</span><span class="p">,</span> <span class="n">colpiece</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span> <span class="n">needg</span><span class="p">)</span>
            <span class="n">y</span><span class="p">[</span><span class="n">curRow</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmpout</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">rec</span><span class="p">:</span>
                <span class="n">rowpiece</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">curRow</span>
            <span class="n">curNg</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LQRnG</span>
            <span class="n">curRow</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># still in the point, path, obj order</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonPointObj</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonPointObj</span><span class="p">:</span>
                <span class="n">tmpx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="n">useT</span><span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">index</span><span class="p">]],</span> <span class="n">useX</span><span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">index</span><span class="p">],</span> <span class="n">useU</span><span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">index</span><span class="p">],</span> <span class="n">useP</span><span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">index</span><span class="p">]))</span>
                <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">autonomous</span><span class="p">:</span>
                    <span class="n">Gpiece</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">obj</span><span class="o">.</span><span class="n">nG</span><span class="p">]</span>
                    <span class="n">rowpiece</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">obj</span><span class="o">.</span><span class="n">nG</span><span class="p">]</span>
                    <span class="n">colpiece</span> <span class="o">=</span> <span class="n">col</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">obj</span><span class="o">.</span><span class="n">nG</span><span class="p">]</span>
                    <span class="n">obj</span><span class="o">.</span><span class="n">__callg__</span><span class="p">(</span><span class="n">tmpx</span><span class="p">,</span> <span class="n">tmpout</span><span class="p">,</span> <span class="n">Gpiece</span><span class="p">,</span> <span class="n">rowpiece</span><span class="p">,</span> <span class="n">colpiece</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span> <span class="n">needg</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">rec</span><span class="p">:</span>
                        <span class="n">rowpiece</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">curRow</span>
                        <span class="n">colpiece</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__patchCol__</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">colpiece</span><span class="p">)</span>
                    <span class="n">curNg</span> <span class="o">+=</span> <span class="n">obj</span><span class="o">.</span><span class="n">nG</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">obj</span><span class="o">.</span><span class="n">__callg__</span><span class="p">(</span><span class="n">tmpx</span><span class="p">,</span> <span class="n">tmpout</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span> <span class="n">needg</span><span class="p">)</span>
                    <span class="n">curNg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__copy_into_g__</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">curRow</span><span class="p">,</span> <span class="n">curNg</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">nG</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">timeindex</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">)</span>
                <span class="n">y</span><span class="p">[</span><span class="n">curRow</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmpout</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">curRow</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonPathObj</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nPoint</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">weight</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="n">h</span>
            <span class="n">weight</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="n">h</span>
            <span class="n">weight</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">6.0</span> <span class="o">*</span> <span class="n">h</span>
            <span class="n">weight</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">6.0</span> <span class="o">*</span> <span class="n">h</span>
            <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonPathObj</span><span class="p">:</span>
                <span class="n">y</span><span class="p">[</span><span class="n">curRow</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">autonomous</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nPoint</span><span class="p">):</span>
                        <span class="n">tmpx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="n">useT</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">useX</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">useU</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">useP</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                        <span class="n">Gpiece</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">obj</span><span class="o">.</span><span class="n">nG</span><span class="p">]</span>
                        <span class="n">rowpiece</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">obj</span><span class="o">.</span><span class="n">nG</span><span class="p">]</span>
                        <span class="n">colpiece</span> <span class="o">=</span> <span class="n">col</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">obj</span><span class="o">.</span><span class="n">nG</span><span class="p">]</span>
                        <span class="n">obj</span><span class="o">.</span><span class="n">__callg__</span><span class="p">(</span><span class="n">tmpx</span><span class="p">,</span> <span class="n">tmpout</span><span class="p">,</span> <span class="n">Gpiece</span><span class="p">,</span> <span class="n">rowpiece</span><span class="p">,</span> <span class="n">colpiece</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span> <span class="n">needg</span><span class="p">)</span>
                        <span class="n">Gpiece</span><span class="p">[:]</span> <span class="o">*=</span> <span class="n">weight</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">rec</span><span class="p">:</span>
                            <span class="n">rowpiece</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">curRow</span>
                            <span class="n">colpiece</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__patchCol__</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">colpiece</span><span class="p">)</span>
                        <span class="n">curNg</span> <span class="o">+=</span> <span class="n">obj</span><span class="o">.</span><span class="n">nG</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nPoint</span><span class="p">):</span>
                        <span class="n">tmpx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="n">useT</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">useX</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">useU</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">useP</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                        <span class="n">obj</span><span class="o">.</span><span class="n">__callg__</span><span class="p">(</span><span class="n">tmpx</span><span class="p">,</span> <span class="n">tmpout</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span> <span class="n">needg</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">[:</span><span class="n">obj</span><span class="o">.</span><span class="n">nG</span><span class="p">]</span> <span class="o">*=</span> <span class="n">weight</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="n">curNg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__copy_into_g__</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="o">.</span> <span class="n">curRow</span><span class="p">,</span> <span class="n">curNg</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">nG</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">timeindex</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">)</span>
                <span class="n">y</span><span class="p">[</span><span class="n">curRow</span><span class="p">]</span> <span class="o">+=</span> <span class="n">weight</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">tmpout</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">curRow</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonLinObj</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonLinObj</span><span class="p">:</span>  <span class="c1"># nonlinear cost function</span>
                <span class="n">Gpiece</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">obj</span><span class="o">.</span><span class="n">nG</span><span class="p">]</span>
                <span class="n">rowpiece</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">obj</span><span class="o">.</span><span class="n">nG</span><span class="p">]</span>
                <span class="n">colpiece</span> <span class="o">=</span> <span class="n">col</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">obj</span><span class="o">.</span><span class="n">nG</span><span class="p">]</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">__callg__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">tmpout</span><span class="p">,</span> <span class="n">Gpiece</span><span class="p">,</span> <span class="n">rowpiece</span><span class="p">,</span> <span class="n">colpiece</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span> <span class="n">needg</span><span class="p">)</span>
                <span class="n">y</span><span class="p">[</span><span class="n">curRow</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmpout</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">rec</span><span class="p">:</span>
                    <span class="n">rowpiece</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">curRow</span>
                <span class="n">curNg</span> <span class="o">+=</span> <span class="n">obj</span><span class="o">.</span><span class="n">nG</span>
                <span class="n">curRow</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">curRow</span><span class="p">,</span> <span class="n">curNg</span>

    <span class="k">def</span> <span class="nf">__constr_mode_g__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">curRow</span><span class="p">,</span> <span class="n">curNg</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">useT</span><span class="p">,</span> <span class="n">useX</span><span class="p">,</span> <span class="n">useU</span><span class="p">,</span> <span class="n">useP</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span> <span class="n">needg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate constraint function. G mode</span>

<span class="sd">        :param curRow: int, index from which we write on</span>
<span class="sd">        :param curNg: int, current index in G</span>
<span class="sd">        :param h, useT, useX, useU, useP: parsed solution</span>
<span class="sd">        :param y: ndarray, the F to be written</span>
<span class="sd">        :param G, row, col: ndarray, the G to be written and the locations</span>
<span class="sd">        :param rec: bool, if we record row and col</span>
<span class="sd">        :param needg: bool, if we need gradient information</span>
<span class="sd">        :returns: curRow: current row after we write on y</span>
<span class="sd">        :returns: curNg: current index in G after this</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># loop over other constraints</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pointConstr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">constr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointConstr</span><span class="p">:</span>
                <span class="n">tmpx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="n">useT</span><span class="p">[</span><span class="n">constr</span><span class="o">.</span><span class="n">index</span><span class="p">]],</span> <span class="n">useX</span><span class="p">[</span><span class="n">constr</span><span class="o">.</span><span class="n">index</span><span class="p">],</span> <span class="n">useU</span><span class="p">[</span><span class="n">constr</span><span class="o">.</span><span class="n">index</span><span class="p">],</span> <span class="n">useP</span><span class="p">[</span><span class="n">constr</span><span class="o">.</span><span class="n">index</span><span class="p">]))</span>
                <span class="k">if</span> <span class="n">constr</span><span class="o">.</span><span class="n">autonomous</span><span class="p">:</span>
                    <span class="n">pieceG</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">constr</span><span class="o">.</span><span class="n">nG</span><span class="p">]</span>
                    <span class="n">pieceRow</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">constr</span><span class="o">.</span><span class="n">nG</span><span class="p">]</span>
                    <span class="n">pieceCol</span> <span class="o">=</span> <span class="n">col</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">constr</span><span class="o">.</span><span class="n">nG</span><span class="p">]</span>
                    <span class="n">constr</span><span class="o">.</span><span class="n">__callg__</span><span class="p">(</span><span class="n">tmpx</span><span class="p">,</span> <span class="n">y</span><span class="p">[</span><span class="n">curRow</span><span class="p">:</span> <span class="n">curRow</span> <span class="o">+</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span><span class="p">],</span> <span class="n">pieceG</span><span class="p">,</span> <span class="n">pieceRow</span><span class="p">,</span> <span class="n">pieceCol</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span> <span class="n">needg</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">rec</span><span class="p">:</span>
                        <span class="n">pieceRow</span> <span class="o">+=</span> <span class="n">curRow</span>
                        <span class="n">pieceCol</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__patchCol__</span><span class="p">(</span><span class="n">constr</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">pieceCol</span><span class="p">)</span>
                    <span class="n">curNg</span> <span class="o">+=</span> <span class="n">constr</span><span class="o">.</span><span class="n">nG</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">constr</span><span class="o">.</span><span class="n">__callg__</span><span class="p">(</span><span class="n">tmpx</span><span class="p">,</span> <span class="n">y</span><span class="p">[</span><span class="n">curRow</span><span class="p">:</span> <span class="n">curRow</span> <span class="o">+</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span> <span class="n">needg</span><span class="p">)</span>
                    <span class="n">curNg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__copy_into_g__</span><span class="p">(</span><span class="n">constr</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">curRow</span><span class="p">,</span> <span class="n">curNg</span><span class="p">,</span> <span class="n">constr</span><span class="o">.</span><span class="n">nG</span><span class="p">,</span> <span class="n">constr</span><span class="o">.</span><span class="n">timeindex</span><span class="p">,</span>
                                                 <span class="kc">True</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">)</span>
                <span class="n">curRow</span> <span class="o">+=</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pathConstr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">constr</span><span class="p">,</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pathConstr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pathConstrIndexPairs</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">constr</span><span class="o">.</span><span class="n">autonomous</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">colloc_constr_is_on</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">j</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                                <span class="k">continue</span>
                        <span class="n">i</span> <span class="o">=</span> <span class="n">j</span>
                        <span class="n">tmpx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="n">useT</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">useX</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">useU</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">useP</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                        <span class="n">pieceG</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">constr</span><span class="o">.</span><span class="n">nG</span><span class="p">]</span>
                        <span class="n">pieceRow</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">constr</span><span class="o">.</span><span class="n">nG</span><span class="p">]</span>
                        <span class="n">pieceCol</span> <span class="o">=</span> <span class="n">col</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">constr</span><span class="o">.</span><span class="n">nG</span><span class="p">]</span>
                        <span class="n">constr</span><span class="o">.</span><span class="n">__callg__</span><span class="p">(</span><span class="n">tmpx</span><span class="p">,</span> <span class="n">y</span><span class="p">[</span><span class="n">curRow</span><span class="p">:</span> <span class="n">curRow</span> <span class="o">+</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span><span class="p">],</span> <span class="n">pieceG</span><span class="p">,</span> <span class="n">pieceRow</span><span class="p">,</span> <span class="n">pieceCol</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span> <span class="n">needg</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">rec</span><span class="p">:</span>
                            <span class="n">pieceRow</span> <span class="o">+=</span> <span class="n">curRow</span>
                            <span class="n">pieceCol</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__patchCol__</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">pieceCol</span><span class="p">)</span>
                        <span class="n">curRow</span> <span class="o">+=</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span>
                        <span class="n">curNg</span> <span class="o">+=</span> <span class="n">constr</span><span class="o">.</span><span class="n">nG</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">colloc_constr_is_on</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">j</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                                <span class="k">continue</span>
                        <span class="n">i</span> <span class="o">=</span> <span class="n">j</span>
                        <span class="n">tmpx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="n">useT</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">useX</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">useU</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">useP</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                        <span class="n">constr</span><span class="o">.</span><span class="n">__callg__</span><span class="p">(</span><span class="n">tmpx</span><span class="p">,</span> <span class="n">y</span><span class="p">[</span><span class="n">curRow</span><span class="p">:</span> <span class="n">curRow</span> <span class="o">+</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span> <span class="n">needg</span><span class="p">)</span>
                        <span class="n">curNg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__copy_into_g__</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">curRow</span><span class="p">,</span> <span class="n">curNg</span><span class="p">,</span> <span class="n">constr</span><span class="o">.</span><span class="n">nG</span><span class="p">,</span> <span class="n">constr</span><span class="o">.</span><span class="n">timeindex</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span>
                                                     <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">)</span>
                        <span class="n">curRow</span> <span class="o">+=</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nonLinConstr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">constr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonLinConstr</span><span class="p">:</span>
                <span class="n">pieceG</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">constr</span><span class="o">.</span><span class="n">nG</span><span class="p">]</span>
                <span class="n">pieceRow</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">constr</span><span class="o">.</span><span class="n">nG</span><span class="p">]</span>
                <span class="n">pieceCol</span> <span class="o">=</span> <span class="n">col</span><span class="p">[</span><span class="n">curNg</span><span class="p">:</span> <span class="n">curNg</span> <span class="o">+</span> <span class="n">constr</span><span class="o">.</span><span class="n">nG</span><span class="p">]</span>
                <span class="n">constr</span><span class="o">.</span><span class="n">__callg__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">[</span><span class="n">curRow</span><span class="p">:</span> <span class="n">curRow</span> <span class="o">+</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span><span class="p">],</span> <span class="n">pieceG</span><span class="p">,</span> <span class="n">pieceRow</span><span class="p">,</span> <span class="n">pieceCol</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span> <span class="n">needg</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">rec</span><span class="p">:</span>
                    <span class="n">pieceRow</span> <span class="o">+=</span> <span class="n">curRow</span>
                <span class="n">curRow</span> <span class="o">+=</span> <span class="n">constr</span><span class="o">.</span><span class="n">nf</span>
                <span class="n">curNg</span> <span class="o">+=</span> <span class="n">constr</span><span class="o">.</span><span class="n">nG</span>
        <span class="k">return</span> <span class="n">curRow</span><span class="p">,</span> <span class="n">curNg</span>

    <span class="c1"># interface functions for ipopt</span>
<div class="viewcode-block" id="trajOptCollocProblem.ipEvalF"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptCollocationProblem.trajOptCollocProblem.ipEvalF">[docs]</a>    <span class="k">def</span> <span class="nf">ipEvalF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The eval_f function required by ipopt.</span>

<span class="sd">        :param x: a guess/solution of the problem</span>
<span class="sd">        :return f: float, objective function</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">row0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spA</span><span class="o">.</span><span class="n">getrow</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">row0</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="n">row0</span><span class="o">.</span><span class="n">indices</span><span class="p">])</span></div>

<div class="viewcode-block" id="trajOptCollocProblem.ipEvalGradF"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptCollocationProblem.trajOptCollocProblem.ipEvalGradF">[docs]</a>    <span class="k">def</span> <span class="nf">ipEvalGradF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluation of the gradient of objective function.</span>

<span class="sd">        :param x: guess/solution to the problem</span>
<span class="sd">        :return grad: gradient of objective function w.r.t x</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">spA</span><span class="o">.</span><span class="n">getrow</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span></div>

<div class="viewcode-block" id="trajOptCollocProblem.ipEvalG"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptCollocationProblem.trajOptCollocProblem.ipEvalG">[docs]</a>    <span class="k">def</span> <span class="nf">ipEvalG</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluation of the constraint function.</span>

<span class="sd">        :param x: ndarray, guess/solution to the problem.</span>
<span class="sd">        :return g: constraint function</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numF</span><span class="p">)</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__callg__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="c1"># y should plus A times x</span>
        <span class="n">y</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spA</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">y</span></div>

<div class="viewcode-block" id="trajOptCollocProblem.ipEvalJacG"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptCollocationProblem.trajOptCollocProblem.ipEvalJacG">[docs]</a>    <span class="k">def</span> <span class="nf">ipEvalJacG</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">flag</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate jacobian of constraints. I simply call __callg__</span>

<span class="sd">        :param x: ndarray, guess / solution to the problem</span>
<span class="sd">        :param flag: bool, True return row/col, False return values</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numF</span><span class="p">)</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nG</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">spA</span><span class="o">.</span><span class="n">nnz</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">flag</span><span class="p">:</span>
            <span class="n">row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nG</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">spA</span><span class="o">.</span><span class="n">nnz</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nG</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">spA</span><span class="o">.</span><span class="n">nnz</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">tmpx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">randomGenX</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__callg__</span><span class="p">(</span><span class="n">tmpx</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="c1"># good news is there is no overlap of A and G</span>
            <span class="n">row</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nG</span><span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spA_coo</span><span class="o">.</span><span class="n">row</span>
            <span class="n">col</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nG</span><span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spA_coo</span><span class="o">.</span><span class="n">col</span>
            <span class="k">return</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__callg__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="n">G</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nG</span><span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spA_coo</span><span class="o">.</span><span class="n">data</span>
            <span class="k">return</span> <span class="n">G</span></div>

    <span class="k">def</span> <span class="nf">__patchCol__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">col_offset</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find which indices it belongs to the original one for a local matrix at index with col.</span>

<span class="sd">        Since we have changed how variables are arranged, now it should be quite straightforward to do so.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">col</span> <span class="o">=</span> <span class="n">col</span><span class="p">[</span><span class="n">col</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># get rid of those with time</span>
        <span class="k">return</span> <span class="n">col</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">getStateIndexByIndex</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">+</span> <span class="n">col_offset</span>

<div class="viewcode-block" id="trajOptCollocProblem.parse_sol"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptCollocationProblem.trajOptCollocProblem.parse_sol">[docs]</a>    <span class="k">def</span> <span class="nf">parse_sol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sol</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Call parseX function from utility and return a dict of solution.&quot;&quot;&quot;</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parseX__</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">P</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">h</span><span class="p">,</span> <span class="n">tgrid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_time_grid__</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parseObj__</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lenAddX</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;t&#39;</span><span class="p">:</span> <span class="n">tgrid</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span> <span class="s1">&#39;u&#39;</span><span class="p">:</span> <span class="n">U</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">:</span> <span class="n">P</span><span class="p">,</span> <span class="s1">&#39;obj&#39;</span><span class="p">:</span> <span class="n">obj</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;t&#39;</span><span class="p">:</span> <span class="n">tgrid</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span> <span class="s1">&#39;u&#39;</span><span class="p">:</span> <span class="n">U</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">:</span> <span class="n">P</span><span class="p">,</span> <span class="s1">&#39;addx&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parseAddX__</span><span class="p">(</span><span class="n">sol</span><span class="p">),</span> <span class="s1">&#39;obj&#39;</span><span class="p">:</span> <span class="n">obj</span><span class="p">}</span></div>

<div class="viewcode-block" id="trajOptCollocProblem.addLQRObj"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptCollocationProblem.trajOptCollocProblem.addLQRObj">[docs]</a>    <span class="k">def</span> <span class="nf">addLQRObj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lqrobj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a lqr objective function to the problem. It changes lqrObj into a function being called.</span>

<span class="sd">        :param lqrobj: a lqrObj class.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Fcol</span> <span class="o">=</span> <span class="n">lqrobj</span><span class="o">.</span><span class="n">F</span><span class="o">.</span><span class="n">col</span>
        <span class="n">Qcol</span> <span class="o">=</span> <span class="n">lqrobj</span><span class="o">.</span><span class="n">Q</span><span class="o">.</span><span class="n">col</span>
        <span class="n">Rcol</span> <span class="o">=</span> <span class="n">lqrobj</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">col</span>
        <span class="n">useF</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Fcol</span><span class="p">)</span>
        <span class="n">useQ</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Qcol</span><span class="p">)</span>
        <span class="n">useR</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Rcol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">useF</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">useQ</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">Fcol</span><span class="p">,</span> <span class="n">Qcol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lqrobj</span><span class="o">.</span><span class="n">P</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Pcol</span> <span class="o">=</span> <span class="n">lqrobj</span><span class="o">.</span><span class="n">P</span><span class="o">.</span><span class="n">col</span>
            <span class="n">useP</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Pcol</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">useP</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">Pcol</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">lqrobj</span><span class="o">.</span><span class="n">tfweight</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tfweight</span> <span class="o">=</span> <span class="n">lqrobj</span><span class="o">.</span><span class="n">tfweight</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tfweight</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">nPoint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nPoint</span>
        <span class="n">num1</span> <span class="o">=</span> <span class="n">nPoint</span> <span class="o">*</span> <span class="p">(</span><span class="n">useQ</span> <span class="o">+</span> <span class="n">useR</span> <span class="o">+</span> <span class="n">useP</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">LQRnG</span> <span class="o">=</span> <span class="n">num1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">numT</span>
        <span class="k">if</span> <span class="n">useF</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">useQ</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">LQRnG</span> <span class="o">+=</span> <span class="n">useF</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nPoint</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">weight</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="mf">3.0</span>
        <span class="n">weight</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">3.0</span>
        <span class="n">weight</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">6.0</span>
        <span class="n">weight</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">6.0</span>
        <span class="n">baseCol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimpoint</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nPoint</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>  <span class="c1"># a nPoint by 1 column matrix</span>

        <span class="k">def</span> <span class="nf">__callg__</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">useX</span><span class="p">,</span> <span class="n">useU</span><span class="p">,</span> <span class="n">useP_</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span> <span class="n">needg</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Calculate the lqr cost with gradient information.</span>

<span class="sd">            :param h: float, grid size</span>
<span class="sd">            :param useX, useU, useP: ndarray, parsed X, U, P from x</span>
<span class="sd">            :param y: ndarray, a location to write the objective function onto</span>
<span class="sd">            :param G/row/col: the gradient information</span>
<span class="sd">            :param rec: if we record row and col</span>
<span class="sd">            :param needg: if we need gradient information.</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">rec</span><span class="p">:</span>
                <span class="n">row</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">col_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">col</span><span class="p">[:</span><span class="n">num1</span><span class="p">],</span> <span class="p">(</span><span class="n">nPoint</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">yF</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">yQ</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">yR</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">yP</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">yTf</span> <span class="o">=</span> <span class="n">tfweight</span> <span class="o">*</span> <span class="p">(</span><span class="n">h</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">curG</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">needg</span><span class="p">:</span>
                <span class="n">G_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">G</span><span class="p">[:</span><span class="n">num1</span><span class="p">],</span> <span class="p">(</span><span class="n">nPoint</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>  <span class="c1"># use the same structure with col_</span>
            <span class="k">if</span> <span class="n">useQ</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">yQ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">weight</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(((</span><span class="n">useX</span><span class="p">[:,</span> <span class="n">Qcol</span><span class="p">]</span> <span class="o">-</span> <span class="n">lqrobj</span><span class="o">.</span><span class="n">xbase</span><span class="p">[</span><span class="n">Qcol</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">lqrobj</span><span class="o">.</span><span class="n">Q</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">h</span>
                <span class="k">if</span> <span class="n">needg</span><span class="p">:</span>
                    <span class="n">G_</span><span class="p">[:,</span> <span class="p">:</span><span class="n">useQ</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">h</span> <span class="o">*</span> <span class="p">(</span><span class="n">weight</span> <span class="o">*</span> <span class="p">((</span><span class="n">useX</span><span class="p">[:,</span> <span class="n">Qcol</span><span class="p">]</span> <span class="o">-</span> <span class="n">lqrobj</span><span class="o">.</span><span class="n">xbase</span><span class="p">[</span><span class="n">Qcol</span><span class="p">])</span> <span class="o">*</span> <span class="n">lqrobj</span><span class="o">.</span><span class="n">Q</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">rec</span><span class="p">:</span>
                        <span class="n">col_</span><span class="p">[:,</span> <span class="p">:</span><span class="n">useQ</span><span class="p">]</span> <span class="o">=</span> <span class="n">Qcol</span> <span class="o">+</span> <span class="n">baseCol</span>
                    <span class="n">curG</span> <span class="o">+=</span> <span class="n">nPoint</span> <span class="o">*</span> <span class="n">useQ</span>
            <span class="k">if</span> <span class="n">useR</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">yR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">weight</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(((</span><span class="n">useU</span><span class="p">[:,</span> <span class="n">Rcol</span><span class="p">]</span> <span class="o">-</span> <span class="n">lqrobj</span><span class="o">.</span><span class="n">ubase</span><span class="p">[</span><span class="n">Rcol</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">lqrobj</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">h</span>
                <span class="k">if</span> <span class="n">needg</span><span class="p">:</span>
                    <span class="n">G_</span><span class="p">[:,</span> <span class="n">useQ</span><span class="p">:</span> <span class="n">useQ</span> <span class="o">+</span> <span class="n">useR</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">h</span> <span class="o">*</span> <span class="p">(</span><span class="n">weight</span> <span class="o">*</span> <span class="p">((</span><span class="n">useU</span><span class="p">[:,</span> <span class="n">Rcol</span><span class="p">]</span> <span class="o">-</span> <span class="n">lqrobj</span><span class="o">.</span><span class="n">ubase</span><span class="p">[</span><span class="n">Rcol</span><span class="p">])</span> <span class="o">*</span> <span class="n">lqrobj</span><span class="o">.</span><span class="n">R</span><span class="o">.</span><span class="n">data</span><span class="p">)))</span>
                    <span class="k">if</span> <span class="n">rec</span><span class="p">:</span>
                        <span class="n">col_</span><span class="p">[:,</span> <span class="n">useQ</span><span class="p">:</span> <span class="n">useQ</span><span class="o">+</span><span class="n">useR</span><span class="p">]</span> <span class="o">=</span> <span class="n">Rcol</span> <span class="o">+</span> <span class="n">baseCol</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span>
                    <span class="n">curG</span> <span class="o">+=</span> <span class="n">nPoint</span> <span class="o">*</span> <span class="n">useR</span>
            <span class="k">if</span> <span class="n">useP</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">yP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">weight</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(((</span><span class="n">useP_</span><span class="p">[:,</span> <span class="n">Pcol</span><span class="p">]</span> <span class="o">-</span> <span class="n">lqrobj</span><span class="o">.</span><span class="n">pbase</span><span class="p">[</span><span class="n">Pcol</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">lqrobj</span><span class="o">.</span><span class="n">P</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">h</span>
                <span class="k">if</span> <span class="n">needg</span><span class="p">:</span>
                    <span class="n">G_</span><span class="p">[:,</span> <span class="n">useQ</span><span class="o">+</span><span class="n">useR</span><span class="p">:</span> <span class="n">useQ</span><span class="o">+</span><span class="n">useR</span><span class="o">+</span><span class="n">useP</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">h</span> <span class="o">*</span> <span class="p">(</span><span class="n">weight</span> <span class="o">*</span> <span class="p">((</span><span class="n">useP_</span><span class="p">[:,</span> <span class="n">Pcol</span><span class="p">]</span> <span class="o">-</span> <span class="n">lqrobj</span><span class="o">.</span><span class="n">pbase</span><span class="p">[</span><span class="n">Pcol</span><span class="p">])</span> <span class="o">*</span> <span class="n">lqrobj</span><span class="o">.</span><span class="n">P</span><span class="o">.</span><span class="n">data</span><span class="p">)))</span>
                    <span class="k">if</span> <span class="n">rec</span><span class="p">:</span>
                        <span class="n">col_</span><span class="p">[:,</span> <span class="n">useQ</span><span class="o">+</span><span class="n">useR</span><span class="p">:</span> <span class="n">useQ</span><span class="o">+</span><span class="n">useR</span><span class="o">+</span><span class="n">useP</span><span class="p">]</span> <span class="o">=</span> <span class="n">Pcol</span> <span class="o">+</span> <span class="n">baseCol</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimu</span>
                    <span class="n">curG</span> <span class="o">+=</span> <span class="n">nPoint</span> <span class="o">*</span> <span class="n">useP</span>
            <span class="k">if</span> <span class="n">useF</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">yF</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">lqrobj</span><span class="o">.</span><span class="n">F</span><span class="o">.</span><span class="n">data</span> <span class="o">*</span> <span class="p">((</span><span class="n">useX</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Fcol</span><span class="p">]</span> <span class="o">-</span> <span class="n">lqrobj</span><span class="o">.</span><span class="n">xfbase</span><span class="p">[</span><span class="n">Fcol</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">useQ</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">needg</span><span class="p">:</span>
                        <span class="n">n0</span> <span class="o">=</span> <span class="n">curG</span> <span class="o">-</span> <span class="n">numPoint</span> <span class="o">*</span> <span class="p">(</span><span class="n">useR</span> <span class="o">+</span> <span class="n">useP</span><span class="p">)</span> <span class="o">-</span> <span class="n">useF</span>  <span class="c1"># locate at the last row</span>
                        <span class="n">G</span><span class="p">[</span><span class="n">n0</span><span class="p">:</span> <span class="n">n0</span> <span class="o">+</span> <span class="n">useF</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">lqrobj</span><span class="o">.</span><span class="n">F</span><span class="o">.</span><span class="n">data</span> <span class="o">*</span> <span class="p">(</span><span class="n">useX</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Fcol</span><span class="p">]</span> <span class="o">-</span> <span class="n">lqrobj</span><span class="o">.</span><span class="n">xfbase</span><span class="p">[</span><span class="n">Fcol</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">G</span><span class="p">[</span><span class="n">curG</span><span class="p">:</span> <span class="n">curG</span> <span class="o">+</span> <span class="n">useF</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">lqrobj</span><span class="o">.</span><span class="n">F</span><span class="o">.</span><span class="n">data</span> <span class="o">*</span> <span class="p">(</span><span class="n">useX</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Fcol</span><span class="p">]</span> <span class="o">-</span> <span class="n">lqrobj</span><span class="o">.</span><span class="n">xfbase</span><span class="p">[</span><span class="n">Fcol</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">rec</span><span class="p">:</span>
                        <span class="n">col</span><span class="p">[</span><span class="n">curG</span><span class="p">:</span> <span class="n">curG</span> <span class="o">+</span> <span class="n">useF</span><span class="p">]</span> <span class="o">=</span> <span class="n">Fcol</span> <span class="o">+</span> <span class="n">baseCol</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">curG</span> <span class="o">+=</span> <span class="n">useF</span>
            <span class="k">if</span> <span class="n">needg</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0ind</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">h</span> <span class="o">&lt;=</span> <span class="mf">1e-8</span><span class="p">:</span>
                        <span class="k">pass</span>
                    <span class="n">G</span><span class="p">[</span><span class="n">curG</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">yQ</span> <span class="o">+</span> <span class="n">yR</span> <span class="o">+</span> <span class="n">yP</span><span class="p">)</span> <span class="o">/</span> <span class="n">h</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">tfweight</span>
                    <span class="k">if</span> <span class="n">rec</span><span class="p">:</span>
                        <span class="n">col</span><span class="p">[</span><span class="n">curG</span><span class="p">:</span> <span class="n">curG</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t0ind</span>
                    <span class="n">curG</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tfind</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">G</span><span class="p">[</span><span class="n">curG</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">yQ</span> <span class="o">+</span> <span class="n">yR</span> <span class="o">+</span> <span class="n">yP</span><span class="p">)</span> <span class="o">/</span> <span class="n">h</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">tfweight</span>
                    <span class="k">if</span> <span class="n">rec</span><span class="p">:</span>
                        <span class="n">col</span><span class="p">[</span><span class="n">curG</span><span class="p">:</span> <span class="n">curG</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tfind</span>
                    <span class="n">curG</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">yF</span> <span class="o">+</span> <span class="n">yQ</span> <span class="o">+</span> <span class="n">yR</span> <span class="o">+</span> <span class="n">yP</span> <span class="o">+</span> <span class="n">yTf</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">lqrObj</span> <span class="o">=</span> <span class="n">__callg__</span></div>

<div class="viewcode-block" id="trajOptCollocProblem.addVanillaQuadPenalty"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptCollocationProblem.trajOptCollocProblem.addVanillaQuadPenalty">[docs]</a>    <span class="k">def</span> <span class="nf">addVanillaQuadPenalty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a quadratic penalty term based on indices in the solution vector and weights.</span>

<span class="sd">        This is dangerous and might cause unexpected trouble unless you are sure indices are correct.</span>
<span class="sd">        You can always use addStateQuadPenalty/addControlQuadPenalty/addParamQuadPenalty/addAddXQuadPenalty to finish these.</span>

<span class="sd">        :param indices: indices of variables to be penalized</span>
<span class="sd">        :param weights: float/ndarray weights associated with those variables.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addNonLinearObj</span><span class="p">(</span><span class="n">quadPenalty</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">weights</span><span class="p">))</span></div>

<div class="viewcode-block" id="trajOptCollocProblem.addStateQuadPenalty"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptCollocationProblem.trajOptCollocProblem.addStateQuadPenalty">[docs]</a>    <span class="k">def</span> <span class="nf">addStateQuadPenalty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a quadratic penalty on selected state variables.</span>

<span class="sd">        :param index: int/array-like, indices of state variables to be penalized.</span>
<span class="sd">        :param weights: float/array-like, weights of penalty</span>
<span class="sd">        :param mask: mask-like, filter for selecting subset of variables</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stateindex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
            <span class="n">useweight</span> <span class="o">=</span> <span class="n">weights</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">useweight</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">index</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">stateindex</span><span class="p">:</span>
            <span class="n">i0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getStateIndexByIndex</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">i0</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">i0</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span><span class="p">)[</span><span class="n">mask</span><span class="p">])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
                <span class="n">useweight</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">useweight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">useweight</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addVanillaQuadPenalty</span><span class="p">(</span><span class="n">indexes</span><span class="p">,</span> <span class="n">useweight</span><span class="p">)</span></div>

<div class="viewcode-block" id="trajOptCollocProblem.addControlQuadPenalty"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptCollocationProblem.trajOptCollocProblem.addControlQuadPenalty">[docs]</a>    <span class="k">def</span> <span class="nf">addControlQuadPenalty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a quadratic penalty on selected control variables.</span>

<span class="sd">        :param index: int/array-like, indices of control variables to be penalized.</span>
<span class="sd">        :param weights: float/array-like, weights of penalty</span>
<span class="sd">        :param mask: filter to select subset</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ctrlindex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
            <span class="n">useweight</span> <span class="o">=</span> <span class="n">weights</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">useweight</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">index</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">ctrlindex</span><span class="p">:</span>
            <span class="n">i0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getControlIndexByIndex</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">i0</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimu</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">i0</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimu</span><span class="p">)[</span><span class="n">mask</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">useweight</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">useweight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">useweight</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addVanillaQuadPenalty</span><span class="p">(</span><span class="n">indexes</span><span class="p">,</span> <span class="n">useweight</span><span class="p">)</span></div>

<div class="viewcode-block" id="trajOptCollocProblem.addParamQuadPenalty"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptCollocationProblem.trajOptCollocProblem.addParamQuadPenalty">[docs]</a>    <span class="k">def</span> <span class="nf">addParamQuadPenalty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a quadratic penalty on selected parameter variables.</span>

<span class="sd">        :param index: int/array-like, indices of parameter variables to be penalized.</span>
<span class="sd">        :param weights: float/array-like, weights of penalty</span>
<span class="sd">        :param mask: filter of variables</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">paramindex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
            <span class="n">useweight</span> <span class="o">=</span> <span class="n">weights</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">useweight</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">index</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">ctrlindex</span><span class="p">:</span>
            <span class="n">i0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getParamIndexByIndex</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">i0</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimp</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">i0</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimp</span><span class="p">)[</span><span class="n">mask</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">useweight</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">useweight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">useweight</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addVanillaQuadPenalty</span><span class="p">(</span><span class="n">indexes</span><span class="p">,</span> <span class="n">useweight</span><span class="p">)</span></div>

<div class="viewcode-block" id="trajOptCollocProblem.addAddXQuadPenalty"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptCollocationProblem.trajOptCollocProblem.addAddXQuadPenalty">[docs]</a>    <span class="k">def</span> <span class="nf">addAddXQuadPenalty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add quadratic penalty to addx variables.</span>

<span class="sd">        The API is slightly different from previous three since we cannot guarantee weights are of the same lenght.</span>

<span class="sd">        :param index: int, indices of parameter variables to be penalized.</span>
<span class="sd">        :param weights: float/array-like, weights of penalty</span>
<span class="sd">        :param mask: filter</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">i0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAddXIndexByIndex</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="n">naddx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">addX</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">n</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">i0</span> <span class="o">+</span> <span class="n">naddx</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">i0</span> <span class="o">+</span> <span class="n">naddx</span><span class="p">)[</span><span class="n">mask</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addVanillaQuadPenalty</span><span class="p">(</span><span class="n">indexes</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span></div>

<div class="viewcode-block" id="trajOptCollocProblem.addLinearObj"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptCollocationProblem.trajOptCollocProblem.addLinearObj">[docs]</a>    <span class="k">def</span> <span class="nf">addLinearObj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linObj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add linear objective function.</span>

<span class="sd">        :param linObj: linearObj class</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">linObj</span><span class="p">,</span> <span class="n">linearObj</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linearObj</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">linObj</span><span class="p">)</span></div>

<div class="viewcode-block" id="trajOptCollocProblem.addLinearPointObj"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptCollocationProblem.trajOptCollocProblem.addLinearPointObj">[docs]</a>    <span class="k">def</span> <span class="nf">addLinearPointObj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linPointObj</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add linear point objective function.</span>

<span class="sd">        :param linPointObj: linearPointObj class</span>
<span class="sd">        :param path: bool, if this is path obj (at every point except for final one)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">linPointObj</span><span class="p">,</span> <span class="n">linearPointObj</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">path</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">linPathObj</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">linPointObj</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">linPointObj</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">linPointObj</span><span class="p">)</span></div>

<div class="viewcode-block" id="trajOptCollocProblem.addNonLinearObj"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptCollocationProblem.trajOptCollocProblem.addNonLinearObj">[docs]</a>    <span class="k">def</span> <span class="nf">addNonLinearObj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nonlinObj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add nonlinear objective function.</span>

<span class="sd">        :param nonLinObj: a nonLinObj class</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nonlinObj</span><span class="p">,</span> <span class="n">nonLinearObj</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonLinObj</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nonlinObj</span><span class="p">)</span></div>

<div class="viewcode-block" id="trajOptCollocProblem.addNonLinearPointObj"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptCollocationProblem.trajOptCollocProblem.addNonLinearPointObj">[docs]</a>    <span class="k">def</span> <span class="nf">addNonLinearPointObj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nonPntObj</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add nonlinear point objective.</span>

<span class="sd">        :param nonPntObj: nonLinObj class</span>
<span class="sd">        :param path: bool, if this obj is pointwise</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nonPntObj</span><span class="p">,</span> <span class="n">nonLinearPointObj</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">path</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nonPathObj</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nonPntObj</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nonPointObj</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nonPntObj</span><span class="p">)</span></div>

<div class="viewcode-block" id="trajOptCollocProblem.addNonLinearPointConstr"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptCollocationProblem.trajOptCollocProblem.addNonLinearPointConstr">[docs]</a>    <span class="k">def</span> <span class="nf">addNonLinearPointConstr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pntConstr</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add point constraint.</span>

<span class="sd">        :param pntConstr: pointConstr class</span>
<span class="sd">        :param path: bool, if this obj</span>
<span class="sd">        :kwargs: additional parameters, users can specify starting and ending indexes by specifying start and end</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pntConstr</span><span class="p">,</span> <span class="n">nonLinearPointConstr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">path</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;start&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;end&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">end</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">+</span> <span class="n">end</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pathConstr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pntConstr</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pathConstrIndexPairs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pointConstr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pntConstr</span><span class="p">)</span></div>

<div class="viewcode-block" id="trajOptCollocProblem.addNonLinearConstr"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptCollocationProblem.trajOptCollocProblem.addNonLinearConstr">[docs]</a>    <span class="k">def</span> <span class="nf">addNonLinearConstr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a general nonlinear constraint.</span>

<span class="sd">        :param constr: nonLinConstr class</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">constr</span><span class="p">,</span> <span class="n">nonLinearConstr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonLinConstr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">constr</span><span class="p">)</span></div>

<div class="viewcode-block" id="trajOptCollocProblem.addLinearConstr"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptCollocationProblem.trajOptCollocProblem.addLinearConstr">[docs]</a>    <span class="k">def</span> <span class="nf">addLinearConstr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a linear constraint to the problem.</span>

<span class="sd">        :param constr: a linearConstr object</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">constr</span><span class="p">,</span> <span class="n">linearConstr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linearConstr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">constr</span><span class="p">)</span></div>

<div class="viewcode-block" id="trajOptCollocProblem.addLinearPointConstr"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptCollocationProblem.trajOptCollocProblem.addLinearPointConstr">[docs]</a>    <span class="k">def</span> <span class="nf">addLinearPointConstr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constr</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a linear point constraint to the problem.</span>

<span class="sd">        :param constr: a linearPointConstr object</span>
<span class="sd">        :param path: if this constraint is path constraint</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">constr</span><span class="p">,</span> <span class="n">linearPointConstr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">path</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">linPathConstr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">constr</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">linPointConstr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">constr</span><span class="p">)</span></div>

<div class="viewcode-block" id="trajOptCollocProblem.addObj"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptCollocationProblem.trajOptCollocProblem.addObj">[docs]</a>    <span class="k">def</span> <span class="nf">addObj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A high level function that add objective function of any kind.</span>

<span class="sd">        :param obj: an objective object.</span>
<span class="sd">        :param path: bool, if the point objective is an integral one.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">linearObj</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addLinearObj</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">linearPointObj</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addLinearPointObj</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">nonLinearObj</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addNonLinearObj</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">nonLinearPointObj</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addNonLinearPointObj</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">lqrObj</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addLQRObj</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span></div>

<div class="viewcode-block" id="trajOptCollocProblem.addConstr"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptCollocationProblem.trajOptCollocProblem.addConstr">[docs]</a>    <span class="k">def</span> <span class="nf">addConstr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constr</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a constraint to the problem.</span>

<span class="sd">        :param constr: a constraint object.</span>
<span class="sd">        :param path: bool, if this constraint is a path constraint. Only applies for point constraint.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">constr</span><span class="p">,</span> <span class="n">linearConstr</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addLinearConstr</span><span class="p">(</span><span class="n">constr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">constr</span><span class="p">,</span> <span class="n">linearPointConstr</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addLinearPointConstr</span><span class="p">(</span><span class="n">constr</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">constr</span><span class="p">,</span> <span class="n">nonLinearConstr</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addNonLinearConstr</span><span class="p">(</span><span class="n">constr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">constr</span><span class="p">,</span> <span class="n">nonLinearPointConstr</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addNonLinearPointConstr</span><span class="p">(</span><span class="n">constr</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="trajOptCollocProblem.setN"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptCollocationProblem.trajOptCollocProblem.setN">[docs]</a>    <span class="k">def</span> <span class="nf">setN</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set N.</span>

<span class="sd">        :param N: the size of discretization.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="n">N</span></div>

<div class="viewcode-block" id="trajOptCollocProblem.sett0tf"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptCollocationProblem.trajOptCollocProblem.sett0tf">[docs]</a>    <span class="k">def</span> <span class="nf">sett0tf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">tf</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set t0 and tf.</span>

<span class="sd">        :param t0: float/ndarray (2,) allowable t0</span>
<span class="sd">        :param tf: float/ndarray (2,) allowable tf</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t0</span> <span class="o">=</span> <span class="n">t0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tf</span> <span class="o">=</span> <span class="n">tf</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">tf</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fixtf</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fixtf</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">assert</span> <span class="n">tf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">tf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">t0</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fixt0</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fixt0</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">assert</span> <span class="n">t0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">t0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="trajOptCollocProblem.setXbound"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptCollocationProblem.trajOptCollocProblem.setXbound">[docs]</a>    <span class="k">def</span> <span class="nf">setXbound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xlb</span><span class="p">,</span> <span class="n">xub</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set bounds on state variables.</span>

<span class="sd">        :param xlb: ndarray, (dimx,) lower bounds on state variables.</span>
<span class="sd">        :param xub: ndarray, (dimx,) upper bounds on state variables.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xlb</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Incorrect length of xlb, it must be </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xub</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Incorrect length of xub, it must be </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xbd</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xlb</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xub</span><span class="p">)]</span></div>

<div class="viewcode-block" id="trajOptCollocProblem.setUbound"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptCollocationProblem.trajOptCollocProblem.setUbound">[docs]</a>    <span class="k">def</span> <span class="nf">setUbound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ulb</span><span class="p">,</span> <span class="n">uub</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set bounds on control variables.</span>

<span class="sd">        :param ulb: ndarray, (dimu,) lower bounds on control variables.</span>
<span class="sd">        :param uub: ndarray, (dimu,) upper bounds on control variables.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ulb</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimu</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Incorrect length of ulb, it must be </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimu</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">uub</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimu</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Incorrect length of uub, it must be </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimu</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ubd</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ulb</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">uub</span><span class="p">)]</span></div>

<div class="viewcode-block" id="trajOptCollocProblem.setPbound"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptCollocationProblem.trajOptCollocProblem.setPbound">[docs]</a>    <span class="k">def</span> <span class="nf">setPbound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plb</span><span class="p">,</span> <span class="n">pub</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set bounds on parameter variables.</span>

<span class="sd">        :param plb: ndarray, (dimp,) lower bounds on parameter variables.</span>
<span class="sd">        :param pub: ndarray, (dimp,) upper bounds on parameter variables.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">plb</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimp</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Incorrect length of plb, it must be </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimp</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pub</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimp</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Incorrect length of pub, it must be </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimp</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pbd</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">plb</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pub</span><span class="p">)]</span></div>

<div class="viewcode-block" id="trajOptCollocProblem.setX0bound"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptCollocationProblem.trajOptCollocProblem.setX0bound">[docs]</a>    <span class="k">def</span> <span class="nf">setX0bound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x0lb</span><span class="p">,</span> <span class="n">x0ub</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set bounds on x0. This is optional but useful.</span>

<span class="sd">        :param x0lb: ndarray, (dimx,) lower bounds on x0 variables.</span>
<span class="sd">        :param x0ub: ndarray, (dimx,) upper bounds on x0 variables.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x0lb</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Incorrect length of x0lb, it must be </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x0ub</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Incorrect length of x0ub, it must be </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x0bd</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x0lb</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x0ub</span><span class="p">)]</span></div>

<div class="viewcode-block" id="trajOptCollocProblem.setXfbound"><a class="viewcode-back" href="../../trajOptLib.html#trajOptLib.trajOptCollocationProblem.trajOptCollocProblem.setXfbound">[docs]</a>    <span class="k">def</span> <span class="nf">setXfbound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xflb</span><span class="p">,</span> <span class="n">xfub</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set bounds on xf. This is optional but useful.</span>

<span class="sd">        :param xflb: ndarray, (dimx,) lower bounds on xf variables.</span>
<span class="sd">        :param xfub: ndarray, (dimx,) upper bounds on xf variables.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xflb</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Incorrect length of xflb, it must be </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xfub</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Incorrect length of xfub, it must be </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xfbd</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xflb</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xfub</span><span class="p">)]</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Gao Tang

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    

  

  <script type="text/javascript" src="../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>